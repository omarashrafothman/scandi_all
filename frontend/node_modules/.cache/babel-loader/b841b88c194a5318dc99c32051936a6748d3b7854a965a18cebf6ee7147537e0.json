{"ast":null,"code":"import * as parseley from 'parseley';\nimport { compareSpecificity } from 'parseley';\nvar Ast = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nvar Types = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst treeify = nodes => '▽\\n' + treeifyArray(nodes, thinLines);\nconst thinLines = [['├─', '│ '], ['└─', '  ']];\nconst heavyLines = [['┠─', '┃ '], ['┖─', '  ']];\nconst doubleLines = [['╟─', '║ '], ['╙─', '  ']];\nfunction treeifyArray(nodes) {\n  let tpl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : heavyLines;\n  return prefixItems(tpl, nodes.map(n => treeifyNode(n)));\n}\nfunction treeifyNode(node) {\n  switch (node.type) {\n    case 'terminal':\n      {\n        const vctr = node.valueContainer;\n        return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n      }\n    case 'tagName':\n      return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n    case 'attrValue':\n      return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n    case 'attrPresence':\n      return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n    case 'pushElement':\n      return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n    case 'popElement':\n      return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n    case 'variant':\n      return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n    case 'matcher':\n      return `◈ ${node.matcher} \"${node.value}\"${node.modifier || ''}\\n${treeifyArray(node.cont)}`;\n  }\n}\nfunction prefixItems(tpl, items) {\n  return items.map((item, i, _ref) => {\n    let {\n      length\n    } = _ref;\n    return prefixItem(tpl, item, i === length - 1);\n  }).join('\\n');\n}\nfunction prefixItem(tpl, item) {\n  let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const tpl1 = tpl[tail ? 1 : 0];\n  return tpl1[0] + item.split('\\n').join('\\n' + tpl1[1]);\n}\nvar TreeifyBuilder = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  treeify: treeify\n});\nclass DecisionTree {\n  constructor(input) {\n    this.branches = weave(toAstTerminalPairs(input));\n  }\n  build(builder) {\n    return builder(this.branches);\n  }\n}\nfunction toAstTerminalPairs(array) {\n  const len = array.length;\n  const results = new Array(len);\n  for (let i = 0; i < len; i++) {\n    const [selectorString, val] = array[i];\n    const ast = preprocess(parseley.parse1(selectorString));\n    results[i] = {\n      ast: ast,\n      terminal: {\n        type: 'terminal',\n        valueContainer: {\n          index: i,\n          value: val,\n          specificity: ast.specificity\n        }\n      }\n    };\n  }\n  return results;\n}\nfunction preprocess(ast) {\n  reduceSelectorVariants(ast);\n  parseley.normalize(ast);\n  return ast;\n}\nfunction reduceSelectorVariants(ast) {\n  const newList = [];\n  ast.list.forEach(sel => {\n    switch (sel.type) {\n      case 'class':\n        newList.push({\n          matcher: '~=',\n          modifier: null,\n          name: 'class',\n          namespace: null,\n          specificity: sel.specificity,\n          type: 'attrValue',\n          value: sel.name\n        });\n        break;\n      case 'id':\n        newList.push({\n          matcher: '=',\n          modifier: null,\n          name: 'id',\n          namespace: null,\n          specificity: sel.specificity,\n          type: 'attrValue',\n          value: sel.name\n        });\n        break;\n      case 'combinator':\n        reduceSelectorVariants(sel.left);\n        newList.push(sel);\n        break;\n      case 'universal':\n        break;\n      default:\n        newList.push(sel);\n        break;\n    }\n  });\n  ast.list = newList;\n}\nfunction weave(items) {\n  const branches = [];\n  while (items.length) {\n    const topKind = findTopKey(items, sel => true, getSelectorKind);\n    const {\n      matches,\n      nonmatches,\n      empty\n    } = breakByKind(items, topKind);\n    items = nonmatches;\n    if (matches.length) {\n      branches.push(branchOfKind(topKind, matches));\n    }\n    if (empty.length) {\n      branches.push(...terminate(empty));\n    }\n  }\n  return branches;\n}\nfunction terminate(items) {\n  const results = [];\n  for (const item of items) {\n    const terminal = item.terminal;\n    if (terminal.type === 'terminal') {\n      results.push(terminal);\n    } else {\n      const {\n        matches,\n        rest\n      } = partition(terminal.cont, node => node.type === 'terminal');\n      matches.forEach(node => results.push(node));\n      if (rest.length) {\n        terminal.cont = rest;\n        results.push(terminal);\n      }\n    }\n  }\n  return results;\n}\nfunction breakByKind(items, selectedKind) {\n  const matches = [];\n  const nonmatches = [];\n  const empty = [];\n  for (const item of items) {\n    const simpsels = item.ast.list;\n    if (simpsels.length) {\n      const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);\n      (isMatch ? matches : nonmatches).push(item);\n    } else {\n      empty.push(item);\n    }\n  }\n  return {\n    matches,\n    nonmatches,\n    empty\n  };\n}\nfunction getSelectorKind(sel) {\n  switch (sel.type) {\n    case 'attrPresence':\n      return `attrPresence ${sel.name}`;\n    case 'attrValue':\n      return `attrValue ${sel.name}`;\n    case 'combinator':\n      return `combinator ${sel.combinator}`;\n    default:\n      return sel.type;\n  }\n}\nfunction branchOfKind(kind, items) {\n  if (kind === 'tag') {\n    return tagNameBranch(items);\n  }\n  if (kind.startsWith('attrValue ')) {\n    return attrValueBranch(kind.substring(10), items);\n  }\n  if (kind.startsWith('attrPresence ')) {\n    return attrPresenceBranch(kind.substring(13), items);\n  }\n  if (kind === 'combinator >') {\n    return combinatorBranch('>', items);\n  }\n  if (kind === 'combinator +') {\n    return combinatorBranch('+', items);\n  }\n  throw new Error(`Unsupported selector kind: ${kind}`);\n}\nfunction tagNameBranch(items) {\n  const groups = spliceAndGroup(items, x => x.type === 'tag', x => x.name);\n  const variants = Object.entries(groups).map(_ref2 => {\n    let [name, group] = _ref2;\n    return {\n      type: 'variant',\n      value: name,\n      cont: weave(group.items)\n    };\n  });\n  return {\n    type: 'tagName',\n    variants: variants\n  };\n}\nfunction attrPresenceBranch(name, items) {\n  for (const item of items) {\n    spliceSimpleSelector(item, x => x.type === 'attrPresence' && x.name === name);\n  }\n  return {\n    type: 'attrPresence',\n    name: name,\n    cont: weave(items)\n  };\n}\nfunction attrValueBranch(name, items) {\n  const groups = spliceAndGroup(items, x => x.type === 'attrValue' && x.name === name, x => `${x.matcher} ${x.modifier || ''} ${x.value}`);\n  const matchers = [];\n  for (const group of Object.values(groups)) {\n    const sel = group.oneSimpleSelector;\n    const predicate = getAttrPredicate(sel);\n    const continuation = weave(group.items);\n    matchers.push({\n      type: 'matcher',\n      matcher: sel.matcher,\n      modifier: sel.modifier,\n      value: sel.value,\n      predicate: predicate,\n      cont: continuation\n    });\n  }\n  return {\n    type: 'attrValue',\n    name: name,\n    matchers: matchers\n  };\n}\nfunction getAttrPredicate(sel) {\n  if (sel.modifier === 'i') {\n    const expected = sel.value.toLowerCase();\n    switch (sel.matcher) {\n      case '=':\n        return actual => expected === actual.toLowerCase();\n      case '~=':\n        return actual => actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n      case '^=':\n        return actual => actual.toLowerCase().startsWith(expected);\n      case '$=':\n        return actual => actual.toLowerCase().endsWith(expected);\n      case '*=':\n        return actual => actual.toLowerCase().includes(expected);\n      case '|=':\n        return actual => {\n          const lower = actual.toLowerCase();\n          return expected === lower || lower.startsWith(expected) && lower[expected.length] === '-';\n        };\n    }\n  } else {\n    const expected = sel.value;\n    switch (sel.matcher) {\n      case '=':\n        return actual => expected === actual;\n      case '~=':\n        return actual => actual.split(/[ \\t]+/).includes(expected);\n      case '^=':\n        return actual => actual.startsWith(expected);\n      case '$=':\n        return actual => actual.endsWith(expected);\n      case '*=':\n        return actual => actual.includes(expected);\n      case '|=':\n        return actual => expected === actual || actual.startsWith(expected) && actual[expected.length] === '-';\n    }\n  }\n}\nfunction combinatorBranch(combinator, items) {\n  const groups = spliceAndGroup(items, x => x.type === 'combinator' && x.combinator === combinator, x => parseley.serialize(x.left));\n  const leftItems = [];\n  for (const group of Object.values(groups)) {\n    const rightCont = weave(group.items);\n    const leftAst = group.oneSimpleSelector.left;\n    leftItems.push({\n      ast: leftAst,\n      terminal: {\n        type: 'popElement',\n        cont: rightCont\n      }\n    });\n  }\n  return {\n    type: 'pushElement',\n    combinator: combinator,\n    cont: weave(leftItems)\n  };\n}\nfunction spliceAndGroup(items, predicate, keyCallback) {\n  const groups = {};\n  while (items.length) {\n    const bestKey = findTopKey(items, predicate, keyCallback);\n    const bestKeyPredicate = sel => predicate(sel) && keyCallback(sel) === bestKey;\n    const hasBestKeyPredicate = item => item.ast.list.some(bestKeyPredicate);\n    const {\n      matches,\n      rest\n    } = partition1(items, hasBestKeyPredicate);\n    let oneSimpleSelector = null;\n    for (const item of matches) {\n      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n      if (!oneSimpleSelector) {\n        oneSimpleSelector = splicedNode;\n      }\n    }\n    if (oneSimpleSelector == null) {\n      throw new Error('No simple selector is found.');\n    }\n    groups[bestKey] = {\n      oneSimpleSelector: oneSimpleSelector,\n      items: matches\n    };\n    items = rest;\n  }\n  return groups;\n}\nfunction spliceSimpleSelector(item, predicate) {\n  const simpsels = item.ast.list;\n  const matches = new Array(simpsels.length);\n  let firstIndex = -1;\n  for (let i = simpsels.length; i-- > 0;) {\n    if (predicate(simpsels[i])) {\n      matches[i] = true;\n      firstIndex = i;\n    }\n  }\n  if (firstIndex == -1) {\n    throw new Error(`Couldn't find the required simple selector.`);\n  }\n  const result = simpsels[firstIndex];\n  item.ast.list = simpsels.filter((sel, i) => !matches[i]);\n  return result;\n}\nfunction findTopKey(items, predicate, keyCallback) {\n  const candidates = {};\n  for (const item of items) {\n    const candidates1 = {};\n    for (const node of item.ast.list.filter(predicate)) {\n      candidates1[keyCallback(node)] = true;\n    }\n    for (const key of Object.keys(candidates1)) {\n      if (candidates[key]) {\n        candidates[key]++;\n      } else {\n        candidates[key] = 1;\n      }\n    }\n  }\n  let topKind = '';\n  let topCounter = 0;\n  for (const entry of Object.entries(candidates)) {\n    if (entry[1] > topCounter) {\n      topKind = entry[0];\n      topCounter = entry[1];\n    }\n  }\n  return topKind;\n}\nfunction partition(src, predicate) {\n  const matches = [];\n  const rest = [];\n  for (const x of src) {\n    if (predicate(x)) {\n      matches.push(x);\n    } else {\n      rest.push(x);\n    }\n  }\n  return {\n    matches,\n    rest\n  };\n}\nfunction partition1(src, predicate) {\n  const matches = [];\n  const rest = [];\n  for (const x of src) {\n    if (predicate(x)) {\n      matches.push(x);\n    } else {\n      rest.push(x);\n    }\n  }\n  return {\n    matches,\n    rest\n  };\n}\nclass Picker {\n  constructor(f) {\n    this.f = f;\n  }\n  pickAll(el) {\n    return this.f(el);\n  }\n  pick1(el) {\n    let preferFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const results = this.f(el);\n    const len = results.length;\n    if (len === 0) {\n      return null;\n    }\n    if (len === 1) {\n      return results[0].value;\n    }\n    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;\n    let result = results[0];\n    for (let i = 1; i < len; i++) {\n      const next = results[i];\n      if (comparator(result, next)) {\n        result = next;\n      }\n    }\n    return result.value;\n  }\n}\nfunction comparatorPreferFirst(acc, next) {\n  const diff = compareSpecificity(next.specificity, acc.specificity);\n  return diff > 0 || diff === 0 && next.index < acc.index;\n}\nfunction comparatorPreferLast(acc, next) {\n  const diff = compareSpecificity(next.specificity, acc.specificity);\n  return diff > 0 || diff === 0 && next.index > acc.index;\n}\nexport { Ast, DecisionTree, Picker, TreeifyBuilder as Treeify, Types };","map":{"version":3,"names":["parseley","compareSpecificity","Ast","Object","freeze","__proto__","Types","treeify","nodes","treeifyArray","thinLines","heavyLines","doubleLines","tpl","arguments","length","undefined","prefixItems","map","n","treeifyNode","node","type","vctr","valueContainer","index","JSON","stringify","specificity","value","variants","name","matchers","cont","combinator","matcher","modifier","items","item","i","_ref","prefixItem","join","tail","tpl1","split","TreeifyBuilder","DecisionTree","constructor","input","branches","weave","toAstTerminalPairs","build","builder","array","len","results","Array","selectorString","val","ast","preprocess","parse1","terminal","reduceSelectorVariants","normalize","newList","list","forEach","sel","push","namespace","left","topKind","findTopKey","getSelectorKind","matches","nonmatches","empty","breakByKind","branchOfKind","terminate","rest","partition","selectedKind","simpsels","isMatch","some","kind","tagNameBranch","startsWith","attrValueBranch","substring","attrPresenceBranch","combinatorBranch","Error","groups","spliceAndGroup","x","entries","_ref2","group","spliceSimpleSelector","values","oneSimpleSelector","predicate","getAttrPredicate","continuation","expected","toLowerCase","actual","includes","endsWith","lower","serialize","leftItems","rightCont","leftAst","keyCallback","bestKey","bestKeyPredicate","hasBestKeyPredicate","partition1","splicedNode","firstIndex","result","filter","candidates","candidates1","key","keys","topCounter","entry","src","Picker","f","pickAll","el","pick1","preferFirst","comparator","comparatorPreferFirst","comparatorPreferLast","next","acc","diff","Treeify"],"sources":["F:/scandiweb_store/frontend/node_modules/selderee/lib/selderee.mjs"],"sourcesContent":["import * as parseley from 'parseley';\nimport { compareSpecificity } from 'parseley';\n\nvar Ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst treeify = (nodes) => '▽\\n' + treeifyArray(nodes, thinLines);\nconst thinLines = [['├─', '│ '], ['└─', '  ']];\nconst heavyLines = [['┠─', '┃ '], ['┖─', '  ']];\nconst doubleLines = [['╟─', '║ '], ['╙─', '  ']];\nfunction treeifyArray(nodes, tpl = heavyLines) {\n    return prefixItems(tpl, nodes.map(n => treeifyNode(n)));\n}\nfunction treeifyNode(node) {\n    switch (node.type) {\n        case 'terminal': {\n            const vctr = node.valueContainer;\n            return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;\n        }\n        case 'tagName':\n            return `◻ Tag name\\n${treeifyArray(node.variants, doubleLines)}`;\n        case 'attrValue':\n            return `▣ Attr value: ${node.name}\\n${treeifyArray(node.matchers, doubleLines)}`;\n        case 'attrPresence':\n            return `◨ Attr presence: ${node.name}\\n${treeifyArray(node.cont)}`;\n        case 'pushElement':\n            return `◉ Push element: ${node.combinator}\\n${treeifyArray(node.cont, thinLines)}`;\n        case 'popElement':\n            return `◌ Pop element\\n${treeifyArray(node.cont, thinLines)}`;\n        case 'variant':\n            return `◇ = ${node.value}\\n${treeifyArray(node.cont)}`;\n        case 'matcher':\n            return `◈ ${node.matcher} \"${node.value}\"${node.modifier || ''}\\n${treeifyArray(node.cont)}`;\n    }\n}\nfunction prefixItems(tpl, items) {\n    return items\n        .map((item, i, { length }) => prefixItem(tpl, item, i === length - 1))\n        .join('\\n');\n}\nfunction prefixItem(tpl, item, tail = true) {\n    const tpl1 = tpl[tail ? 1 : 0];\n    return tpl1[0] + item.split('\\n').join('\\n' + tpl1[1]);\n}\n\nvar TreeifyBuilder = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    treeify: treeify\n});\n\nclass DecisionTree {\n    constructor(input) {\n        this.branches = weave(toAstTerminalPairs(input));\n    }\n    build(builder) {\n        return builder(this.branches);\n    }\n}\nfunction toAstTerminalPairs(array) {\n    const len = array.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n        const [selectorString, val] = array[i];\n        const ast = preprocess(parseley.parse1(selectorString));\n        results[i] = {\n            ast: ast,\n            terminal: {\n                type: 'terminal',\n                valueContainer: { index: i, value: val, specificity: ast.specificity }\n            }\n        };\n    }\n    return results;\n}\nfunction preprocess(ast) {\n    reduceSelectorVariants(ast);\n    parseley.normalize(ast);\n    return ast;\n}\nfunction reduceSelectorVariants(ast) {\n    const newList = [];\n    ast.list.forEach(sel => {\n        switch (sel.type) {\n            case 'class':\n                newList.push({\n                    matcher: '~=',\n                    modifier: null,\n                    name: 'class',\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: 'attrValue',\n                    value: sel.name,\n                });\n                break;\n            case 'id':\n                newList.push({\n                    matcher: '=',\n                    modifier: null,\n                    name: 'id',\n                    namespace: null,\n                    specificity: sel.specificity,\n                    type: 'attrValue',\n                    value: sel.name,\n                });\n                break;\n            case 'combinator':\n                reduceSelectorVariants(sel.left);\n                newList.push(sel);\n                break;\n            case 'universal':\n                break;\n            default:\n                newList.push(sel);\n                break;\n        }\n    });\n    ast.list = newList;\n}\nfunction weave(items) {\n    const branches = [];\n    while (items.length) {\n        const topKind = findTopKey(items, (sel) => true, getSelectorKind);\n        const { matches, nonmatches, empty } = breakByKind(items, topKind);\n        items = nonmatches;\n        if (matches.length) {\n            branches.push(branchOfKind(topKind, matches));\n        }\n        if (empty.length) {\n            branches.push(...terminate(empty));\n        }\n    }\n    return branches;\n}\nfunction terminate(items) {\n    const results = [];\n    for (const item of items) {\n        const terminal = item.terminal;\n        if (terminal.type === 'terminal') {\n            results.push(terminal);\n        }\n        else {\n            const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');\n            matches.forEach((node) => results.push(node));\n            if (rest.length) {\n                terminal.cont = rest;\n                results.push(terminal);\n            }\n        }\n    }\n    return results;\n}\nfunction breakByKind(items, selectedKind) {\n    const matches = [];\n    const nonmatches = [];\n    const empty = [];\n    for (const item of items) {\n        const simpsels = item.ast.list;\n        if (simpsels.length) {\n            const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);\n            (isMatch ? matches : nonmatches).push(item);\n        }\n        else {\n            empty.push(item);\n        }\n    }\n    return { matches, nonmatches, empty };\n}\nfunction getSelectorKind(sel) {\n    switch (sel.type) {\n        case 'attrPresence':\n            return `attrPresence ${sel.name}`;\n        case 'attrValue':\n            return `attrValue ${sel.name}`;\n        case 'combinator':\n            return `combinator ${sel.combinator}`;\n        default:\n            return sel.type;\n    }\n}\nfunction branchOfKind(kind, items) {\n    if (kind === 'tag') {\n        return tagNameBranch(items);\n    }\n    if (kind.startsWith('attrValue ')) {\n        return attrValueBranch(kind.substring(10), items);\n    }\n    if (kind.startsWith('attrPresence ')) {\n        return attrPresenceBranch(kind.substring(13), items);\n    }\n    if (kind === 'combinator >') {\n        return combinatorBranch('>', items);\n    }\n    if (kind === 'combinator +') {\n        return combinatorBranch('+', items);\n    }\n    throw new Error(`Unsupported selector kind: ${kind}`);\n}\nfunction tagNameBranch(items) {\n    const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);\n    const variants = Object.entries(groups).map(([name, group]) => ({\n        type: 'variant',\n        value: name,\n        cont: weave(group.items)\n    }));\n    return {\n        type: 'tagName',\n        variants: variants\n    };\n}\nfunction attrPresenceBranch(name, items) {\n    for (const item of items) {\n        spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));\n    }\n    return {\n        type: 'attrPresence',\n        name: name,\n        cont: weave(items)\n    };\n}\nfunction attrValueBranch(name, items) {\n    const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);\n    const matchers = [];\n    for (const group of Object.values(groups)) {\n        const sel = group.oneSimpleSelector;\n        const predicate = getAttrPredicate(sel);\n        const continuation = weave(group.items);\n        matchers.push({\n            type: 'matcher',\n            matcher: sel.matcher,\n            modifier: sel.modifier,\n            value: sel.value,\n            predicate: predicate,\n            cont: continuation\n        });\n    }\n    return {\n        type: 'attrValue',\n        name: name,\n        matchers: matchers\n    };\n}\nfunction getAttrPredicate(sel) {\n    if (sel.modifier === 'i') {\n        const expected = sel.value.toLowerCase();\n        switch (sel.matcher) {\n            case '=':\n                return (actual) => expected === actual.toLowerCase();\n            case '~=':\n                return (actual) => actual.toLowerCase().split(/[ \\t]+/).includes(expected);\n            case '^=':\n                return (actual) => actual.toLowerCase().startsWith(expected);\n            case '$=':\n                return (actual) => actual.toLowerCase().endsWith(expected);\n            case '*=':\n                return (actual) => actual.toLowerCase().includes(expected);\n            case '|=':\n                return (actual) => {\n                    const lower = actual.toLowerCase();\n                    return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');\n                };\n        }\n    }\n    else {\n        const expected = sel.value;\n        switch (sel.matcher) {\n            case '=':\n                return (actual) => expected === actual;\n            case '~=':\n                return (actual) => actual.split(/[ \\t]+/).includes(expected);\n            case '^=':\n                return (actual) => actual.startsWith(expected);\n            case '$=':\n                return (actual) => actual.endsWith(expected);\n            case '*=':\n                return (actual) => actual.includes(expected);\n            case '|=':\n                return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');\n        }\n    }\n}\nfunction combinatorBranch(combinator, items) {\n    const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => parseley.serialize(x.left));\n    const leftItems = [];\n    for (const group of Object.values(groups)) {\n        const rightCont = weave(group.items);\n        const leftAst = group.oneSimpleSelector.left;\n        leftItems.push({\n            ast: leftAst,\n            terminal: { type: 'popElement', cont: rightCont }\n        });\n    }\n    return {\n        type: 'pushElement',\n        combinator: combinator,\n        cont: weave(leftItems)\n    };\n}\nfunction spliceAndGroup(items, predicate, keyCallback) {\n    const groups = {};\n    while (items.length) {\n        const bestKey = findTopKey(items, predicate, keyCallback);\n        const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;\n        const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);\n        const { matches, rest } = partition1(items, hasBestKeyPredicate);\n        let oneSimpleSelector = null;\n        for (const item of matches) {\n            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);\n            if (!oneSimpleSelector) {\n                oneSimpleSelector = splicedNode;\n            }\n        }\n        if (oneSimpleSelector == null) {\n            throw new Error('No simple selector is found.');\n        }\n        groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };\n        items = rest;\n    }\n    return groups;\n}\nfunction spliceSimpleSelector(item, predicate) {\n    const simpsels = item.ast.list;\n    const matches = new Array(simpsels.length);\n    let firstIndex = -1;\n    for (let i = simpsels.length; i-- > 0;) {\n        if (predicate(simpsels[i])) {\n            matches[i] = true;\n            firstIndex = i;\n        }\n    }\n    if (firstIndex == -1) {\n        throw new Error(`Couldn't find the required simple selector.`);\n    }\n    const result = simpsels[firstIndex];\n    item.ast.list = simpsels.filter((sel, i) => !matches[i]);\n    return result;\n}\nfunction findTopKey(items, predicate, keyCallback) {\n    const candidates = {};\n    for (const item of items) {\n        const candidates1 = {};\n        for (const node of item.ast.list.filter(predicate)) {\n            candidates1[keyCallback(node)] = true;\n        }\n        for (const key of Object.keys(candidates1)) {\n            if (candidates[key]) {\n                candidates[key]++;\n            }\n            else {\n                candidates[key] = 1;\n            }\n        }\n    }\n    let topKind = '';\n    let topCounter = 0;\n    for (const entry of Object.entries(candidates)) {\n        if (entry[1] > topCounter) {\n            topKind = entry[0];\n            topCounter = entry[1];\n        }\n    }\n    return topKind;\n}\nfunction partition(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src) {\n        if (predicate(x)) {\n            matches.push(x);\n        }\n        else {\n            rest.push(x);\n        }\n    }\n    return { matches, rest };\n}\nfunction partition1(src, predicate) {\n    const matches = [];\n    const rest = [];\n    for (const x of src) {\n        if (predicate(x)) {\n            matches.push(x);\n        }\n        else {\n            rest.push(x);\n        }\n    }\n    return { matches, rest };\n}\n\nclass Picker {\n    constructor(f) {\n        this.f = f;\n    }\n    pickAll(el) {\n        return this.f(el);\n    }\n    pick1(el, preferFirst = false) {\n        const results = this.f(el);\n        const len = results.length;\n        if (len === 0) {\n            return null;\n        }\n        if (len === 1) {\n            return results[0].value;\n        }\n        const comparator = (preferFirst)\n            ? comparatorPreferFirst\n            : comparatorPreferLast;\n        let result = results[0];\n        for (let i = 1; i < len; i++) {\n            const next = results[i];\n            if (comparator(result, next)) {\n                result = next;\n            }\n        }\n        return result.value;\n    }\n}\nfunction comparatorPreferFirst(acc, next) {\n    const diff = compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || (diff === 0 && next.index < acc.index);\n}\nfunction comparatorPreferLast(acc, next) {\n    const diff = compareSpecificity(next.specificity, acc.specificity);\n    return diff > 0 || (diff === 0 && next.index > acc.index);\n}\n\nexport { Ast, DecisionTree, Picker, TreeifyBuilder as Treeify, Types };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}