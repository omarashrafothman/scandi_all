{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction noop() {}\nexport var lastWatchOptions = Symbol();\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return wrapHook(\"useQuery\", _useQuery, useApolloClient(options && options.client))(query, options);\n}\nfunction _useQuery(query, options) {\n  var _a = useQueryInternals(query, options),\n    result = _a.result,\n    obsQueryFields = _a.obsQueryFields;\n  return React.useMemo(function () {\n    return __assign(__assign({}, result), obsQueryFields);\n  }, [result, obsQueryFields]);\n}\nfunction useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {\n  function createInternalState(previous) {\n    var _a;\n    verifyDocumentType(query, DocumentType.Query);\n    var internalState = {\n      client: client,\n      query: query,\n      observable:\n      // See if there is an existing observable that was used to fetch the same\n      // data and if so, use it instead since it will contain the proper queryId\n      // to fetch the result set. This is used during SSR.\n      renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions())),\n      resultData: {\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: (_a = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a === void 0 ? void 0 : _a.data\n      }\n    };\n    return internalState;\n  }\n  var _a = React.useState(createInternalState),\n    internalState = _a[0],\n    updateInternalState = _a[1];\n  /**\n   * Used by `useLazyQuery` when a new query is executed.\n   * We keep this logic here since it needs to update things in unsafe\n   * ways and here we at least can keep track of that in a single place.\n   */\n  function onQueryExecuted(watchQueryOptions) {\n    var _a;\n    var _b;\n    // this needs to be set to prevent an immediate `resubscribe` in the\n    // next rerender of the `useQuery` internals\n    Object.assign(internalState.observable, (_a = {}, _a[lastWatchOptions] = watchQueryOptions, _a));\n    var resultData = internalState.resultData;\n    updateInternalState(__assign(__assign({}, internalState), {\n      // might be a different query\n      query: watchQueryOptions.query,\n      resultData: Object.assign(resultData, {\n        // We need to modify the previous `resultData` object as we rely on the\n        // object reference in other places\n        previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,\n        current: undefined\n      })\n    }));\n  }\n  if (client !== internalState.client || query !== internalState.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    var newInternalState = createInternalState(internalState);\n    updateInternalState(newInternalState);\n    return [newInternalState, onQueryExecuted];\n  }\n  return [internalState, onQueryExecuted];\n}\nexport function useQueryInternals(query, options) {\n  var client = useApolloClient(options.client);\n  var renderPromises = React.useContext(getApolloContext()).renderPromises;\n  var isSyncSSR = !!renderPromises;\n  var disableNetworkFetches = client.disableNetworkFetches;\n  var ssrAllowed = options.ssr !== false && !options.skip;\n  var partialRefetch = options.partialRefetch;\n  var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);\n  var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions),\n    _b = _a[0],\n    observable = _b.observable,\n    resultData = _b.resultData,\n    onQueryExecuted = _a[1];\n  var watchQueryOptions = makeWatchQueryOptions(observable);\n  useResubscribeIfNecessary(resultData,\n  // might get mutated during render\n  observable,\n  // might get mutated during render\n  client, options, watchQueryOptions);\n  var obsQueryFields = React.useMemo(function () {\n    return bindObservableMethods(observable);\n  }, [observable]);\n  useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n  var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {\n    onCompleted: options.onCompleted || noop,\n    onError: options.onError || noop\n  });\n  return {\n    result: result,\n    obsQueryFields: obsQueryFields,\n    observable: observable,\n    resultData: resultData,\n    client: client,\n    onQueryExecuted: onQueryExecuted\n  };\n}\nfunction useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {\n  var callbackRef = React.useRef(callbacks);\n  React.useEffect(function () {\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    callbackRef.current = callbacks;\n  });\n  var resultOverride = (isSyncSSR || disableNetworkFetches) && options.ssr === false && !options.skip ?\n  // If SSR has been explicitly disabled, and this function has been called\n  // on the server side, return the default loading state.\n  ssrDisabledResult : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n  // When skipping a query (ie. we're not querying for data but still want to\n  // render children), make sure the `data` is cleared out and `loading` is\n  // set to `false` (since we aren't loading anything).\n  //\n  // NOTE: We no longer think this is the correct behavior. Skipping should\n  // not automatically set `data` to `undefined`, but instead leave the\n  // previous data in place. In other words, skipping should not mandate that\n  // previously received data is all of a sudden removed. Unfortunately,\n  // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n  // to address this.\n  skipStandbyResult : void 0;\n  var previousData = resultData.previousData;\n  var currentResultOverride = React.useMemo(function () {\n    return resultOverride && toQueryResult(resultOverride, previousData, observable, client);\n  }, [client, observable, resultOverride, previousData]);\n  return useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n    // reference `disableNetworkFetches` here to ensure that the rules of hooks\n    // keep it as a dependency of this effect, even though it's not used\n    disableNetworkFetches;\n    if (isSyncSSR) {\n      return function () {};\n    }\n    var onNext = function () {\n      var previousResult = resultData.current;\n      // We use `getCurrentResult()` instead of the onNext argument because\n      // the values differ slightly. Specifically, loading results will have\n      // an empty object for data instead of `undefined` for some reason.\n      var result = observable.getCurrentResult();\n      // Make sure we're not attempting to re-render similar results\n      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n        return;\n      }\n      setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n    };\n    var onError = function (error) {\n      subscription.current.unsubscribe();\n      subscription.current = observable.resubscribeAfterError(onNext, onError);\n      if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n        // The error is not a GraphQL error\n        throw error;\n      }\n      var previousResult = resultData.current;\n      if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n        setResult({\n          data: previousResult && previousResult.data,\n          error: error,\n          loading: false,\n          networkStatus: NetworkStatus.error\n        }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n      }\n    };\n    // TODO evaluate if we keep this in\n    // React Compiler cannot handle scoped `let` access, but a mutable object\n    // like this is fine.\n    // was:\n    // let subscription = observable.subscribe(onNext, onError);\n    var subscription = {\n      current: observable.subscribe(onNext, onError)\n    };\n    // Do the \"unsubscribe\" with a short delay.\n    // This way, an existing subscription can be reused without an additional\n    // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n    // happen in very fast succession.\n    return function () {\n      setTimeout(function () {\n        return subscription.current.unsubscribe();\n      });\n    };\n  }, [disableNetworkFetches, isSyncSSR, observable, resultData, partialRefetch, client]), function () {\n    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n  }, function () {\n    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n  });\n}\nfunction useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {\n  if (renderPromises && ssrAllowed) {\n    renderPromises.registerSSRObservable(observable);\n    if (observable.getCurrentResult().loading) {\n      // TODO: This is a legacy API which could probably be cleaned up\n      renderPromises.addObservableQueryPromise(observable);\n    }\n  }\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(/** this hook will mutate properties on `resultData` */\nresultData, /** this hook will mutate properties on `observable` */\nobservable, client, options, watchQueryOptions) {\n  var _a;\n  if (observable[lastWatchOptions] && !equal(observable[lastWatchOptions], watchQueryOptions)) {\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    resultData.previousData = ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;\n    resultData.current = void 0;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nexport function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {\n  if (_a === void 0) {\n    _a = {};\n  }\n  var skip = _a.skip,\n    ssr = _a.ssr,\n    onCompleted = _a.onCompleted,\n    onError = _a.onError,\n    defaultOptions = _a.defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n  return function (observable) {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    var watchQueryOptions = Object.assign(otherOptions, {\n      query: query\n    });\n    if (isSyncSSR && (watchQueryOptions.fetchPolicy === \"network-only\" || watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {};\n    }\n    if (skip) {\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n      watchQueryOptions.fetchPolicy = \"standby\";\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n    }\n    return watchQueryOptions;\n  };\n}\nexport function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {\n  var toMerge = [];\n  var globalDefaults = client.defaultOptions.watchQuery;\n  if (globalDefaults) toMerge.push(globalDefaults);\n  if (queryHookOptions.defaultOptions) {\n    toMerge.push(queryHookOptions.defaultOptions);\n  }\n  // We use compact rather than mergeOptions for this part of the merge,\n  // because we want watchQueryOptions.variables (if defined) to replace\n  // this.observable.options.variables whole. This replacement allows\n  // removing variables by removing them from the variables input to\n  // useQuery. If the variables were always merged together (rather than\n  // replaced), there would be no way to remove existing variables.\n  // However, the variables from options.defaultOptions and globalDefaults\n  // (if provided) should be merged, to ensure individual defaulted\n  // variables always have values, if not otherwise defined in\n  // observable.options or watchQueryOptions.\n  toMerge.push(compact(observable && observable.options, watchQueryOptions));\n  return toMerge.reduce(mergeOptions);\n}\nfunction setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {\n  var previousResult = resultData.current;\n  if (previousResult && previousResult.data) {\n    resultData.previousData = previousResult.data;\n  }\n  if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {\n    // Until a set naming convention for networkError and graphQLErrors is\n    // decided upon, we map errors (graphQLErrors) to the error options.\n    // TODO: Is it possible for both result.error and result.errors to be\n    // defined here?\n    nextResult.error = new ApolloError({\n      graphQLErrors: nextResult.errors\n    });\n  }\n  resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);\n  // Calling state.setResult always triggers an update, though some call sites\n  // perform additional equality checks before committing to an update.\n  forceUpdate();\n  handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);\n}\nfunction handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {\n  if (!result.loading) {\n    var error_1 = toApolloError(result);\n    // wait a tick in case we are in the middle of rendering a component\n    Promise.resolve().then(function () {\n      if (error_1) {\n        callbacks.onError(error_1);\n      } else if (result.data && previousNetworkStatus !== result.networkStatus && result.networkStatus === NetworkStatus.ready) {\n        callbacks.onCompleted(result.data);\n      }\n    }).catch(function (error) {\n      globalThis.__DEV__ !== false && invariant.warn(error);\n    });\n  }\n}\nfunction getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {\n  // Using this.result as a cache ensures getCurrentResult continues returning\n  // the same (===) result object, unless state.setResult has been called, or\n  // we're doing server rendering and therefore override the result below.\n  if (!resultData.current) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    // this could call unsafeHandlePartialRefetch\n    setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function () {}, callbacks);\n  }\n  return resultData.current;\n}\nexport function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {\n  var _a;\n  return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || \"cache-first\";\n}\nexport function toApolloError(result) {\n  return isNonEmptyArray(result.errors) ? new ApolloError({\n    graphQLErrors: result.errors\n  }) : result.error;\n}\nexport function toQueryResult(result, previousData, observable, client) {\n  var data = result.data,\n    partial = result.partial,\n    resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n  var queryResult = __assign(__assign({\n    data: data\n  }, resultWithoutPartial), {\n    client: client,\n    observable: observable,\n    variables: observable.variables,\n    called: result !== ssrDisabledResult && result !== skipStandbyResult,\n    previousData: previousData\n  });\n  return queryResult;\n}\nfunction unsafeHandlePartialRefetch(result, observable, partialRefetch) {\n  // TODO: This code should be removed when the partialRefetch option is\n  // removed. I was unable to get this hook to behave reasonably in certain\n  // edge cases when this block was put in an effect.\n  if (result.partial && partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && observable.options.fetchPolicy !== \"cache-only\") {\n    observable.refetch();\n    return __assign(__assign({}, result), {\n      loading: true,\n      networkStatus: NetworkStatus.refetch\n    });\n  }\n  return result;\n}\nvar ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0,\n  error: void 0,\n  networkStatus: NetworkStatus.loading\n});\nvar skipStandbyResult = maybeDeepFreeze({\n  loading: false,\n  data: void 0,\n  error: void 0,\n  networkStatus: NetworkStatus.ready\n});\nfunction bindObservableMethods(observable) {\n  return {\n    refetch: observable.refetch.bind(observable),\n    reobserve: observable.reobserve.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable)\n  };\n}","map":{"version":3,"names":["__assign","__rest","invariant","React","useSyncExternalStore","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","compact","isNonEmptyArray","maybeDeepFreeze","wrapHook","hasOwnProperty","Object","prototype","noop","lastWatchOptions","Symbol","useQuery","query","options","create","_useQuery","client","_a","useQueryInternals","result","obsQueryFields","useMemo","useInternalState","renderPromises","makeWatchQueryOptions","createInternalState","previous","Query","internalState","observable","getSSRObservable","watchQuery","getObsQueryOptions","resultData","previousData","current","data","useState","updateInternalState","onQueryExecuted","watchQueryOptions","_b","assign","undefined","newInternalState","useContext","isSyncSSR","disableNetworkFetches","ssrAllowed","ssr","skip","partialRefetch","createMakeWatchQueryOptions","useResubscribeIfNecessary","bindObservableMethods","useRegisterSSRObservable","useObservableSubscriptionResult","onCompleted","onError","callbacks","callbackRef","useRef","useEffect","resultOverride","ssrDisabledResult","fetchPolicy","skipStandbyResult","currentResultOverride","toQueryResult","useCallback","handleStoreChange","onNext","previousResult","getCurrentResult","loading","networkStatus","setResult","error","subscription","unsubscribe","resubscribeAfterError","call","subscribe","setTimeout","registerSSRObservable","addObservableQueryPromise","reobserve","defaultOptions","otherOptions","variables","initialFetchPolicy","getDefaultFetchPolicy","queryHookOptions","toMerge","globalDefaults","push","reduce","nextResult","forceUpdate","errors","graphQLErrors","unsafeHandlePartialRefetch","handleErrorOrCompleted","previousNetworkStatus","error_1","toApolloError","Promise","resolve","then","ready","catch","globalThis","__DEV__","warn","queryHookDefaultOptions","clientDefaultOptions","partial","resultWithoutPartial","queryResult","called","keys","length","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore"],"sources":["C:/laragon/www/php_projects/scandiweb_store/frontend/node_modules/@apollo/client/react/hooks/useQuery.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { compact, isNonEmptyArray, maybeDeepFreeze, } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction noop() { }\nexport var lastWatchOptions = Symbol();\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return wrapHook(\"useQuery\", _useQuery, useApolloClient(options && options.client))(query, options);\n}\nfunction _useQuery(query, options) {\n    var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;\n    return React.useMemo(function () { return (__assign(__assign({}, result), obsQueryFields)); }, [result, obsQueryFields]);\n}\nfunction useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {\n    function createInternalState(previous) {\n        var _a;\n        verifyDocumentType(query, DocumentType.Query);\n        var internalState = {\n            client: client,\n            query: query,\n            observable: \n            // See if there is an existing observable that was used to fetch the same\n            // data and if so, use it instead since it will contain the proper queryId\n            // to fetch the result set. This is used during SSR.\n            (renderPromises &&\n                renderPromises.getSSRObservable(makeWatchQueryOptions())) ||\n                client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions())),\n            resultData: {\n                // Reuse previousData from previous InternalState (if any) to provide\n                // continuity of previousData even if/when the query or client changes.\n                previousData: (_a = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a === void 0 ? void 0 : _a.data,\n            },\n        };\n        return internalState;\n    }\n    var _a = React.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];\n    /**\n     * Used by `useLazyQuery` when a new query is executed.\n     * We keep this logic here since it needs to update things in unsafe\n     * ways and here we at least can keep track of that in a single place.\n     */\n    function onQueryExecuted(watchQueryOptions) {\n        var _a;\n        var _b;\n        // this needs to be set to prevent an immediate `resubscribe` in the\n        // next rerender of the `useQuery` internals\n        Object.assign(internalState.observable, (_a = {},\n            _a[lastWatchOptions] = watchQueryOptions,\n            _a));\n        var resultData = internalState.resultData;\n        updateInternalState(__assign(__assign({}, internalState), { \n            // might be a different query\n            query: watchQueryOptions.query, resultData: Object.assign(resultData, {\n                // We need to modify the previous `resultData` object as we rely on the\n                // object reference in other places\n                previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,\n                current: undefined,\n            }) }));\n    }\n    if (client !== internalState.client || query !== internalState.query) {\n        // If the client or query have changed, we need to create a new InternalState.\n        // This will trigger a re-render with the new state, but it will also continue\n        // to run the current render function to completion.\n        // Since we sometimes trigger some side-effects in the render function, we\n        // re-assign `state` to the new state to ensure that those side-effects are\n        // triggered with the new state.\n        var newInternalState = createInternalState(internalState);\n        updateInternalState(newInternalState);\n        return [newInternalState, onQueryExecuted];\n    }\n    return [internalState, onQueryExecuted];\n}\nexport function useQueryInternals(query, options) {\n    var client = useApolloClient(options.client);\n    var renderPromises = React.useContext(getApolloContext()).renderPromises;\n    var isSyncSSR = !!renderPromises;\n    var disableNetworkFetches = client.disableNetworkFetches;\n    var ssrAllowed = options.ssr !== false && !options.skip;\n    var partialRefetch = options.partialRefetch;\n    var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);\n    var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];\n    var watchQueryOptions = makeWatchQueryOptions(observable);\n    useResubscribeIfNecessary(resultData, // might get mutated during render\n    observable, // might get mutated during render\n    client, options, watchQueryOptions);\n    var obsQueryFields = React.useMemo(function () { return bindObservableMethods(observable); }, [observable]);\n    useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n    var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {\n        onCompleted: options.onCompleted || noop,\n        onError: options.onError || noop,\n    });\n    return {\n        result: result,\n        obsQueryFields: obsQueryFields,\n        observable: observable,\n        resultData: resultData,\n        client: client,\n        onQueryExecuted: onQueryExecuted,\n    };\n}\nfunction useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {\n    var callbackRef = React.useRef(callbacks);\n    React.useEffect(function () {\n        // Make sure state.onCompleted and state.onError always reflect the latest\n        // options.onCompleted and options.onError callbacks provided to useQuery,\n        // since those functions are often recreated every time useQuery is called.\n        // Like the forceUpdate method, the versions of these methods inherited from\n        // InternalState.prototype are empty no-ops, but we can override them on the\n        // base state object (without modifying the prototype).\n        callbackRef.current = callbacks;\n    });\n    var resultOverride = ((isSyncSSR || disableNetworkFetches) &&\n        options.ssr === false &&\n        !options.skip) ?\n        // If SSR has been explicitly disabled, and this function has been called\n        // on the server side, return the default loading state.\n        ssrDisabledResult\n        : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n            // When skipping a query (ie. we're not querying for data but still want to\n            // render children), make sure the `data` is cleared out and `loading` is\n            // set to `false` (since we aren't loading anything).\n            //\n            // NOTE: We no longer think this is the correct behavior. Skipping should\n            // not automatically set `data` to `undefined`, but instead leave the\n            // previous data in place. In other words, skipping should not mandate that\n            // previously received data is all of a sudden removed. Unfortunately,\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n            // to address this.\n            skipStandbyResult\n            : void 0;\n    var previousData = resultData.previousData;\n    var currentResultOverride = React.useMemo(function () {\n        return resultOverride &&\n            toQueryResult(resultOverride, previousData, observable, client);\n    }, [client, observable, resultOverride, previousData]);\n    return useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n        // reference `disableNetworkFetches` here to ensure that the rules of hooks\n        // keep it as a dependency of this effect, even though it's not used\n        disableNetworkFetches;\n        if (isSyncSSR) {\n            return function () { };\n        }\n        var onNext = function () {\n            var previousResult = resultData.current;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            var result = observable.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (previousResult &&\n                previousResult.loading === result.loading &&\n                previousResult.networkStatus === result.networkStatus &&\n                equal(previousResult.data, result.data)) {\n                return;\n            }\n            setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n        };\n        var onError = function (error) {\n            subscription.current.unsubscribe();\n            subscription.current = observable.resubscribeAfterError(onNext, onError);\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n                // The error is not a GraphQL error\n                throw error;\n            }\n            var previousResult = resultData.current;\n            if (!previousResult ||\n                (previousResult && previousResult.loading) ||\n                !equal(error, previousResult.error)) {\n                setResult({\n                    data: (previousResult && previousResult.data),\n                    error: error,\n                    loading: false,\n                    networkStatus: NetworkStatus.error,\n                }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n            }\n        };\n        // TODO evaluate if we keep this in\n        // React Compiler cannot handle scoped `let` access, but a mutable object\n        // like this is fine.\n        // was:\n        // let subscription = observable.subscribe(onNext, onError);\n        var subscription = { current: observable.subscribe(onNext, onError) };\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return function () {\n            setTimeout(function () { return subscription.current.unsubscribe(); });\n        };\n    }, [\n        disableNetworkFetches,\n        isSyncSSR,\n        observable,\n        resultData,\n        partialRefetch,\n        client,\n    ]), function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    }, function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    });\n}\nfunction useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {\n    if (renderPromises && ssrAllowed) {\n        renderPromises.registerSSRObservable(observable);\n        if (observable.getCurrentResult().loading) {\n            // TODO: This is a legacy API which could probably be cleaned up\n            renderPromises.addObservableQueryPromise(observable);\n        }\n    }\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(\n/** this hook will mutate properties on `resultData` */\nresultData, \n/** this hook will mutate properties on `observable` */\nobservable, client, options, watchQueryOptions) {\n    var _a;\n    if (observable[lastWatchOptions] &&\n        !equal(observable[lastWatchOptions], watchQueryOptions)) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        resultData.previousData =\n            ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;\n        resultData.current = void 0;\n    }\n    observable[lastWatchOptions] = watchQueryOptions;\n}\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nexport function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {\n    if (_a === void 0) { _a = {}; }\n    var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    return function (observable) {\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\n        // that did not exist until just now, so modifications are still allowed.\n        var watchQueryOptions = Object.assign(otherOptions, { query: query });\n        if (isSyncSSR &&\n            (watchQueryOptions.fetchPolicy === \"network-only\" ||\n                watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n            // this behavior was added to react-apollo without explanation in this PR\n            // https://github.com/apollographql/react-apollo/pull/1579\n            watchQueryOptions.fetchPolicy = \"cache-first\";\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\n            // \"standby\", but we also need/want to preserve the initial non-standby\n            // fetchPolicy that would have been used if not skipping.\n            watchQueryOptions.initialFetchPolicy =\n                watchQueryOptions.initialFetchPolicy ||\n                    watchQueryOptions.fetchPolicy ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n            watchQueryOptions.fetchPolicy = \"standby\";\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n        }\n        return watchQueryOptions;\n    };\n}\nexport function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {\n    var toMerge = [];\n    var globalDefaults = client.defaultOptions.watchQuery;\n    if (globalDefaults)\n        toMerge.push(globalDefaults);\n    if (queryHookOptions.defaultOptions) {\n        toMerge.push(queryHookOptions.defaultOptions);\n    }\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(observable && observable.options, watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n}\nfunction setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {\n    var previousResult = resultData.current;\n    if (previousResult && previousResult.data) {\n        resultData.previousData = previousResult.data;\n    }\n    if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {\n        // Until a set naming convention for networkError and graphQLErrors is\n        // decided upon, we map errors (graphQLErrors) to the error options.\n        // TODO: Is it possible for both result.error and result.errors to be\n        // defined here?\n        nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });\n    }\n    resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    forceUpdate();\n    handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);\n}\nfunction handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {\n    if (!result.loading) {\n        var error_1 = toApolloError(result);\n        // wait a tick in case we are in the middle of rendering a component\n        Promise.resolve()\n            .then(function () {\n            if (error_1) {\n                callbacks.onError(error_1);\n            }\n            else if (result.data &&\n                previousNetworkStatus !== result.networkStatus &&\n                result.networkStatus === NetworkStatus.ready) {\n                callbacks.onCompleted(result.data);\n            }\n        })\n            .catch(function (error) {\n            globalThis.__DEV__ !== false && invariant.warn(error);\n        });\n    }\n}\nfunction getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!resultData.current) {\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n        // this could call unsafeHandlePartialRefetch\n        setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function () { }, callbacks);\n    }\n    return resultData.current;\n}\nexport function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {\n    var _a;\n    return ((queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) ||\n        ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n        \"cache-first\");\n}\nexport function toApolloError(result) {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n        : result.error;\n}\nexport function toQueryResult(result, previousData, observable, client) {\n    var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    var queryResult = __assign(__assign({ data: data }, resultWithoutPartial), { client: client, observable: observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData: previousData });\n    return queryResult;\n}\nfunction unsafeHandlePartialRefetch(result, observable, partialRefetch) {\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial &&\n        partialRefetch &&\n        !result.loading &&\n        (!result.data || Object.keys(result.data).length === 0) &&\n        observable.options.fetchPolicy !== \"cache-only\") {\n        observable.refetch();\n        return __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });\n    }\n    return result;\n}\nvar ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n});\nvar skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n});\nfunction bindObservableMethods(observable) {\n    return {\n        refetch: observable.refetch.bind(observable),\n        reobserve: observable.reobserve.bind(observable),\n        fetchMore: observable.fetchMore.bind(observable),\n        updateQuery: observable.updateQuery.bind(observable),\n        startPolling: observable.startPolling.bind(observable),\n        stopPolling: observable.stopPolling.bind(observable),\n        subscribeToMore: observable.subscribeToMore.bind(observable),\n    };\n}\n//# sourceMappingURL=useQuery.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}