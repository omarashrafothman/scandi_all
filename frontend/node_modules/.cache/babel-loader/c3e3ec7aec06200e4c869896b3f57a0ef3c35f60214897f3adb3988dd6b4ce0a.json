{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { createMakeWatchQueryOptions, getDefaultFetchPolicy, getObsQueryOptions, toQueryResult, useQueryInternals } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nvar EAGER_METHODS = [\"refetch\", \"reobserve\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"stopPolling\", \"subscribeToMore\"];\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery(query, options) {\n  var _a;\n  var execOptionsRef = React.useRef();\n  var optionsRef = React.useRef();\n  var queryRef = React.useRef();\n  var merged = mergeOptions(options, execOptionsRef.current || {});\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = options;\n  queryRef.current = document;\n  var queryHookOptions = __assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  });\n  var _b = useQueryInternals(document, queryHookOptions),\n    obsQueryFields = _b.obsQueryFields,\n    useQueryResult = _b.result,\n    client = _b.client,\n    resultData = _b.resultData,\n    observable = _b.observable,\n    onQueryExecuted = _b.onQueryExecuted;\n  var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);\n  var forceUpdateState = React.useReducer(function (tick) {\n    return tick + 1;\n  }, 0)[1];\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  var eagerMethods = React.useMemo(function () {\n    var eagerMethods = {};\n    var _loop_1 = function (key) {\n      var method = obsQueryFields[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    };\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n      _loop_1(key);\n    }\n    return eagerMethods;\n  }, [forceUpdateState, obsQueryFields]);\n  var called = !!execOptionsRef.current;\n  var result = React.useMemo(function () {\n    return __assign(__assign(__assign({}, useQueryResult), eagerMethods), {\n      called: called\n    });\n  }, [useQueryResult, eagerMethods, called]);\n  var execute = React.useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = executeQuery(resultData, observable, client, document, __assign(__assign({}, options), {\n      skip: false\n    }), onQueryExecuted).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    });\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(function () {});\n    return promise;\n  }, [client, document, eagerMethods, initialFetchPolicy, observable, resultData, onQueryExecuted]);\n  var executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(function () {\n    executeRef.current = execute;\n  });\n  var stableExecute = React.useCallback(function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return executeRef.current.apply(executeRef, args);\n  }, []);\n  return [stableExecute, result];\n}\nfunction executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {\n  var query = options.query || currentQuery;\n  var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);\n  var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));\n  onQueryExecuted(watchQueryOptions);\n  return new Promise(function (resolve) {\n    var result;\n    // Subscribe to the concast independently of the ObservableQuery in case\n    // the component gets unmounted before the promise resolves. This prevents\n    // the concast from terminating early and resolving with `undefined` when\n    // there are no more subscribers for the concast.\n    concast.subscribe({\n      next: function (value) {\n        result = value;\n      },\n      error: function () {\n        resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));\n      },\n      complete: function () {\n        resolve(toQueryResult(result, resultData.previousData, observable, client));\n      }\n    });\n  });\n}","map":{"version":3,"names":["__assign","React","mergeOptions","createMakeWatchQueryOptions","getDefaultFetchPolicy","getObsQueryOptions","toQueryResult","useQueryInternals","useIsomorphicLayoutEffect","EAGER_METHODS","useLazyQuery","query","options","_a","execOptionsRef","useRef","optionsRef","queryRef","merged","current","document","queryHookOptions","skip","_b","obsQueryFields","useQueryResult","result","client","resultData","observable","onQueryExecuted","initialFetchPolicy","defaultOptions","forceUpdateState","useReducer","tick","eagerMethods","useMemo","_loop_1","key","method","Object","create","apply","arguments","_i","EAGER_METHODS_1","length","called","execute","useCallback","executeOptions","fetchPolicy","promise","executeQuery","then","queryResult","assign","catch","executeRef","stableExecute","args","currentQuery","watchQueryOptions","concast","reobserveAsConcast","Promise","resolve","subscribe","next","value","error","getCurrentResult","previousData","complete"],"sources":["C:/laragon/www/php_projects/scandiweb_store/frontend/node_modules/@apollo/client/react/hooks/useLazyQuery.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { createMakeWatchQueryOptions, getDefaultFetchPolicy, getObsQueryOptions, toQueryResult, useQueryInternals, } from \"./useQuery.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nvar EAGER_METHODS = [\n    \"refetch\",\n    \"reobserve\",\n    \"fetchMore\",\n    \"updateQuery\",\n    \"startPolling\",\n    \"stopPolling\",\n    \"subscribeToMore\",\n];\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery(query, options) {\n    var _a;\n    var execOptionsRef = React.useRef();\n    var optionsRef = React.useRef();\n    var queryRef = React.useRef();\n    var merged = mergeOptions(options, execOptionsRef.current || {});\n    var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n    // Use refs to track options and the used query to ensure the `execute`\n    // function remains referentially stable between renders.\n    optionsRef.current = options;\n    queryRef.current = document;\n    var queryHookOptions = __assign(__assign({}, merged), { skip: !execOptionsRef.current });\n    var _b = useQueryInternals(document, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;\n    var initialFetchPolicy = observable.options.initialFetchPolicy ||\n        getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);\n    var forceUpdateState = React.useReducer(function (tick) { return tick + 1; }, 0)[1];\n    // We use useMemo here to make sure the eager methods have a stable identity.\n    var eagerMethods = React.useMemo(function () {\n        var eagerMethods = {};\n        var _loop_1 = function (key) {\n            var method = obsQueryFields[key];\n            eagerMethods[key] = function () {\n                if (!execOptionsRef.current) {\n                    execOptionsRef.current = Object.create(null);\n                    // Only the first time populating execOptionsRef.current matters here.\n                    forceUpdateState();\n                }\n                // @ts-expect-error this is just too generic to type\n                return method.apply(this, arguments);\n            };\n        };\n        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n            var key = EAGER_METHODS_1[_i];\n            _loop_1(key);\n        }\n        return eagerMethods;\n    }, [forceUpdateState, obsQueryFields]);\n    var called = !!execOptionsRef.current;\n    var result = React.useMemo(function () { return (__assign(__assign(__assign({}, useQueryResult), eagerMethods), { called: called })); }, [useQueryResult, eagerMethods, called]);\n    var execute = React.useCallback(function (executeOptions) {\n        execOptionsRef.current =\n            executeOptions ? __assign(__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {\n                fetchPolicy: initialFetchPolicy,\n            };\n        var options = mergeOptions(optionsRef.current, __assign({ query: queryRef.current }, execOptionsRef.current));\n        var promise = executeQuery(resultData, observable, client, document, __assign(__assign({}, options), { skip: false }), onQueryExecuted).then(function (queryResult) { return Object.assign(queryResult, eagerMethods); });\n        // Because the return value of `useLazyQuery` is usually floated, we need\n        // to catch the promise to prevent unhandled rejections.\n        promise.catch(function () { });\n        return promise;\n    }, [\n        client,\n        document,\n        eagerMethods,\n        initialFetchPolicy,\n        observable,\n        resultData,\n        onQueryExecuted,\n    ]);\n    var executeRef = React.useRef(execute);\n    useIsomorphicLayoutEffect(function () {\n        executeRef.current = execute;\n    });\n    var stableExecute = React.useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return executeRef.current.apply(executeRef, args);\n    }, []);\n    return [stableExecute, result];\n}\nfunction executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {\n    var query = options.query || currentQuery;\n    var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);\n    var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));\n    onQueryExecuted(watchQueryOptions);\n    return new Promise(function (resolve) {\n        var result;\n        // Subscribe to the concast independently of the ObservableQuery in case\n        // the component gets unmounted before the promise resolves. This prevents\n        // the concast from terminating early and resolving with `undefined` when\n        // there are no more subscribers for the concast.\n        concast.subscribe({\n            next: function (value) {\n                result = value;\n            },\n            error: function () {\n                resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));\n            },\n            complete: function () {\n                resolve(toQueryResult(result, resultData.previousData, observable, client));\n            },\n        });\n    });\n}\n//# sourceMappingURL=useLazyQuery.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}