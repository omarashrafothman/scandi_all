{"ast":null,"code":"import { hp2Builder } from '@selderee/plugin-htmlparser2';\nimport { parseDocument } from 'htmlparser2';\nimport { DecisionTree } from 'selderee';\nimport merge from 'deepmerge';\nimport { render } from 'dom-serializer';\n\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */\nfunction limitedDepthRecursive(n, f) {\n  let g = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => undefined;\n  if (n === undefined) {\n    const f1 = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return f(f1, ...args);\n    };\n    return f1;\n  }\n  if (n >= 0) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return f(limitedDepthRecursive(n - 1, f, g), ...args);\n    };\n  }\n  return g;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacter(str, char) {\n  let start = 0;\n  let end = str.length;\n  while (start < end && str[start] === char) {\n    ++start;\n  }\n  while (end > start && str[end - 1] === char) {\n    --end;\n  }\n  return start > 0 || end < str.length ? str.substring(start, end) : str;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacterEnd(str, char) {\n  let end = str.length;\n  while (end > 0 && str[end - 1] === char) {\n    --end;\n  }\n  return end < str.length ? str.substring(0, end) : str;\n}\n\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */\nfunction unicodeEscape(str) {\n  return str.replace(/[\\s\\S]/g, c => '\\\\u' + c.charCodeAt().toString(16).padStart(4, '0'));\n}\n\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */\nfunction mergeDuplicatesPreferLast(items, getKey) {\n  const map = new Map();\n  for (let i = items.length; i-- > 0;) {\n    const item = items[i];\n    const key = getKey(item);\n    map.set(key, map.has(key) ? merge(item, map.get(key), {\n      arrayMerge: overwriteMerge$1\n    }) : item);\n  }\n  return [...map.values()].reverse();\n}\nconst overwriteMerge$1 = (acc, src, options) => [...src];\n\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */\nfunction get(obj, path) {\n  for (const key of path) {\n    if (!obj) {\n      return undefined;\n    }\n    obj = obj[key];\n  }\n  return obj;\n}\n\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */\nfunction numberToLetterSequence(num) {\n  let baseChar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'a';\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 26;\n  const digits = [];\n  do {\n    num -= 1;\n    digits.push(num % base);\n    num = num / base >> 0; // quick `floor`\n  } while (num > 0);\n  const baseCode = baseChar.charCodeAt(0);\n  return digits.reverse().map(n => String.fromCharCode(baseCode + n)).join('');\n}\nconst I = ['I', 'X', 'C', 'M'];\nconst V = ['V', 'L', 'D'];\n\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */\nfunction numberToRoman(num) {\n  return [...(num + '')].map(n => +n).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join('');\n}\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor(options) {\n    let maxLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];\n    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  pushWord(word) {\n    let noWrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.nextLineAvailableChars <= 0 && !noWrap) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if (cost <= this.nextLineAvailableChars || noWrap) {\n      // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n    } else {\n      // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) {\n        this.startNewLine();\n      }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord() {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  concatWord(word) {\n    let noWrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word, noWrap);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({\n        length: n - 1\n      }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty() {\n    return this.lines.length === 0 && this.nextLineWords.length === 0;\n  }\n  clear() {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString() {\n    return [...this.lines, this.nextLineWords].map(words => words.join(' ')).join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord(word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n      if (splitIndex > -1) {\n        // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n      } else {\n        // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) {\n          // There is next character to try\n\n          word = firstLine + remainingChars;\n        } else {\n          // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n        }\n      }\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\n\n/* eslint-disable max-classes-per-file */\n\nclass StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.next = next;\n  }\n  getRoot() {\n    return this.next ? this.next : this;\n  }\n}\nclass BlockStackItem extends StackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let maxLineLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(next);\n    this.leadingLineBreaks = leadingLineBreaks;\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass ListStackItem extends BlockStackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let {\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2,\n      maxLineLength = undefined,\n      maxPrefixLength = 0,\n      prefixAlign = 'left'\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.maxPrefixLength = maxPrefixLength;\n    this.prefixAlign = prefixAlign;\n    this.interRowLineBreaks = interRowLineBreaks;\n  }\n}\nclass ListItemStackItem extends BlockStackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let {\n      leadingLineBreaks = 1,\n      maxLineLength = undefined,\n      prefix = ''\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.prefix = prefix;\n  }\n}\nclass TableStackItem extends StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(next);\n    this.rows = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass TableRowStackItem extends StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(next);\n    this.cells = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass TableCellStackItem extends StackItem {\n  constructor(options) {\n    let next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let maxColumnWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    super(next);\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\nclass TransformerStackItem extends StackItem {\n  constructor() {\n    let next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let transform = arguments.length > 1 ? arguments[1] : undefined;\n    super(next);\n    this.transform = transform;\n  }\n}\nfunction charactersToCodes(str) {\n  return [...str].map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor(options) {\n    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, '') : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n    this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, 'g');\n    this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, 'g');\n    if (options.preserveNewlines) {\n      const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        let transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str => str;\n        let noWrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        if (!text) {\n          return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n    } else {\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n      this.shrinkWrapAdd = function (text, inlineTextBuilder) {\n        let transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str => str;\n        let noWrap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        if (!text) {\n          return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n      };\n    }\n  }\n\n  /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */\n  addLiteral(text, inlineTextBuilder) {\n    let noWrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!text) {\n      return;\n    }\n    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n    let anyMatch = false;\n    let m = this.newlineOrNonNewlineStringRe.exec(text);\n    if (m) {\n      anyMatch = true;\n      if (m[0] === '\\n') {\n        inlineTextBuilder.startNewLine();\n      } else if (previouslyStashedSpace) {\n        inlineTextBuilder.pushWord(m[0], noWrap);\n      } else {\n        inlineTextBuilder.concatWord(m[0], noWrap);\n      }\n      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {\n        if (m[0] === '\\n') {\n          inlineTextBuilder.startNewLine();\n        } else {\n          inlineTextBuilder.pushWord(m[0], noWrap);\n        }\n      }\n    }\n    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace(text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace(text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords(text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n  /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */\n  countNewlinesNoWords(text) {\n    this.newlineOrNonWhitespaceRe.lastIndex = 0;\n    let counter = 0;\n    let match;\n    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {\n      if (match[0] === '\\n') {\n        counter++;\n      } else {\n        return 0;\n      }\n    }\n    return counter;\n  }\n}\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */\n  constructor(options, picker) {\n    let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    this.options = options;\n    this.picker = picker;\n    this.metadata = metadata;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform(wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform() {\n    if (!this._wordTransformer) {\n      return undefined;\n    }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */\n  startNoWrap() {\n    this._stackItem.isNoWrap = true;\n  }\n\n  /**\n   * Return automatic wrapping to behavior defined by options.\n   */\n  stopNoWrap() {\n    this._stackItem.isNoWrap = false;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer() {\n    const wt = this._wordTransformer ? str => applyTransformer(str, this._wordTransformer) : undefined;\n    const ce = this.options.encodeCharacters;\n    return wt ? ce ? str => ce(wt(str)) : wt : ce;\n  }\n  _popStackItem() {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak() {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity() {\n    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */\n  addInline(str) {\n    let {\n      noWordTransform = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n    if (str.length === 0 ||\n    // empty string\n\n    this._stackItem.stashedLineBreaks &&\n    // stashed linebreaks make whitespace irrelevant\n    !this.whitespaceProcessor.testContainsWords(str) // no words to add\n    ) {\n      return;\n    }\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n        // keep stashedLineBreaks unchanged\n        return;\n      }\n    }\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n\n  /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */\n  addLiteral(str) {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (str.length === 0) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);\n    this._stackItem.stashedLineBreaks = 0;\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */\n  openBlock() {\n    let {\n      leadingLineBreaks = 1,\n      reservedLineLength = 0,\n      isPre = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n    if (isPre) {\n      this._stackItem.isPre = true;\n    }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */\n  closeBlock() {\n    let {\n      trailingLineBreaks = 1,\n      blockTransform = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const block = this._popStackItem();\n    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */\n  openList() {\n    let {\n      maxPrefixLength = 0,\n      prefixAlign = 'left',\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._stackItem = new ListStackItem(this.options, this._stackItem, {\n      interRowLineBreaks: interRowLineBreaks,\n      leadingLineBreaks: leadingLineBreaks,\n      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n      maxPrefixLength: maxPrefixLength,\n      prefixAlign: prefixAlign\n    });\n  }\n\n  /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */\n  openListItem() {\n    let {\n      prefix = ''\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!(this._stackItem instanceof ListStackItem)) {\n      throw new Error('Can\\'t add a list item to something that is not a list! Check the formatter.');\n    }\n    const list = this._stackItem;\n    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n    this._stackItem = new ListItemStackItem(this.options, list, {\n      prefix: prefix,\n      maxLineLength: maxLineLength,\n      leadingLineBreaks: list.interRowLineBreaks\n    });\n  }\n\n  /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */\n  closeListItem() {\n    const listItem = this._popStackItem();\n    const list = listItem.next;\n    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n    const spacing = '\\n' + ' '.repeat(prefixLength);\n    const prefix = list.prefixAlign === 'right' ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);\n    const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n    addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));\n  }\n\n  /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */\n  closeList() {\n    let {\n      trailingLineBreaks = 2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const list = this._popStackItem();\n    const text = getText(list);\n    if (text) {\n      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable() {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow() {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add a table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell() {\n    let {\n      maxColumnWidth = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add a table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */\n  closeTableCell() {\n    let {\n      colspan = 1,\n      rowspan = 1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({\n      colspan: colspan,\n      rowspan: rowspan,\n      text: text\n    });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow() {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */\n  closeTable(_ref) {\n    let {\n      tableToString,\n      leadingLineBreaks = 2,\n      trailingLineBreaks = 2\n    } = _ref;\n    const table = this._popStackItem();\n    const output = tableToString(table.rows);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString() {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n}\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks, list items and table cells can be requested for text contents.');\n  }\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks, list items and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */\nfunction applyTransformer(str, transformer) {\n  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n}\n\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile$1() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);\n  if (selectorsWithoutFormat.length) {\n    throw new Error('Following selectors have no specified format: ' + selectorsWithoutFormat.map(s => `\\`${s.selector}\\``).join(', '));\n  }\n  const picker = new DecisionTree(options.selectors.map(s => [s.selector, s])).build(hp2Builder);\n  if (typeof options.encodeCharacters !== 'function') {\n    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n  }\n  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s, i) => [s, i + 1])).build(hp2Builder);\n  function findBaseElements(dom) {\n    return findBases(dom, options, baseSelectorsPicker);\n  }\n  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function (dom, builder) {\n    builder.addInline(options.limits.ellipsis || '');\n  });\n  return function (html) {\n    let metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n  };\n}\n\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */\nfunction process(html, metadata, options, picker, findBaseElements, walk) {\n  const maxInputLength = options.limits.maxInputLength;\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);\n    html = html.substring(0, maxInputLength);\n  }\n  const document = parseDocument(html, {\n    decodeEntities: options.decodeEntities\n  });\n  const bases = findBaseElements(document.children);\n  const builder = new BlockTextBuilder(options, picker, metadata);\n  walk(bases, builder);\n  return builder.toString();\n}\nfunction findBases(dom, options, baseSelectorsPicker) {\n  const results = [];\n  function recursiveWalk(walk, /** @type { DomNode[] } */dom) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    for (const elem of dom) {\n      if (elem.type !== 'tag') {\n        continue;\n      }\n      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n      if (pickedSelectorIndex > 0) {\n        results.push({\n          selectorIndex: pickedSelectorIndex,\n          element: elem\n        });\n      } else if (elem.children) {\n        walk(elem.children);\n      }\n      if (results.length >= options.limits.maxBaseElements) {\n        return;\n      }\n    }\n  }\n  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n  limitedWalk(dom);\n  if (options.baseElements.orderBy !== 'occurrence') {\n    // 'selectors'\n    results.sort((a, b) => a.selectorIndex - b.selectorIndex);\n  }\n  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map(x => x.element);\n}\n\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\nfunction recursiveWalk(walk, dom, builder) {\n  if (!dom) {\n    return;\n  }\n  const options = builder.options;\n  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n  for (const elem of dom) {\n    switch (elem.type) {\n      case 'text':\n        {\n          builder.addInline(elem.data);\n          break;\n        }\n      case 'tag':\n        {\n          const tagDefinition = builder.picker.pick1(elem);\n          const format = options.formatters[tagDefinition.format];\n          format(elem, walk, builder, tagDefinition.options || {});\n          break;\n        }\n    }\n  }\n  return;\n}\n\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */\nfunction makeReplacerFromDict(dict) {\n  if (!dict || Object.keys(dict).length === 0) {\n    return undefined;\n  }\n  /** @type { [string, string][] } */\n  const entries = Object.entries(dict).filter(_ref2 => {\n    let [, v] = _ref2;\n    return v !== false;\n  });\n  const regex = new RegExp(entries.map(_ref3 => {\n    let [c] = _ref3;\n    return `(${unicodeEscape([...c][0])})`;\n  }).join('|'), 'g');\n  const values = entries.map(_ref4 => {\n    let [, v] = _ref4;\n    return v;\n  });\n  const replacer = function (m) {\n    for (var _len3 = arguments.length, cgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      cgs[_key3 - 1] = arguments[_key3];\n    }\n    return values[cgs.findIndex(cg => cg)];\n  };\n  return str => str.replace(regex, replacer);\n}\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip(elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineString(elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.string || '');\n}\n\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockString(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addLiteral(formatOptions.string || '');\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline(elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock$1(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\nfunction renderOpenTag(elem) {\n  const attrs = elem.attribs && elem.attribs.length ? ' ' + Object.entries(elem.attribs).map(_ref5 => {\n    let [k, v] = _ref5;\n    return v === '' ? k : `${k}=${v.replace(/\"/g, '&quot;')}`;\n  }).join(' ') : '';\n  return `<${elem.name}${attrs}>`;\n}\nfunction renderCloseTag(elem) {\n  return `</${elem.name}>`;\n}\n\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineTag(elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockTag(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineHtml(elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(render(elem, {\n    decodeEntities: builder.options.decodeEntities\n  }));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockHtml(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.startNoWrap();\n  builder.addLiteral(render(elem, {\n    decodeEntities: builder.options.decodeEntities\n  }));\n  builder.stopNoWrap();\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineSurround(elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.prefix || '');\n  walk(elem.children, builder);\n  builder.addLiteral(formatOptions.suffix || '');\n}\nvar genericFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  block: formatBlock$1,\n  blockHtml: formatBlockHtml,\n  blockString: formatBlockString,\n  blockTag: formatBlockTag,\n  inline: formatInline,\n  inlineHtml: formatInlineHtml,\n  inlineString: formatInlineString,\n  inlineSurround: formatInlineSurround,\n  inlineTag: formatInlineTag,\n  skip: formatSkip\n});\nfunction getRow(matrix, j) {\n  if (!matrix[j]) {\n    matrix[j] = [];\n  }\n  return matrix[j];\n}\nfunction findFirstVacantIndex(row) {\n  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  while (row[x]) {\n    x++;\n  }\n  return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      if (rowI[j] || rowJ[i]) {\n        const temp = rowI[j];\n        rowI[j] = rowJ[i];\n        rowJ[i] = temp;\n      }\n    }\n  }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\nfunction getOrInitOffset(offsets, index) {\n  if (offsets[index] === undefined) {\n    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);\n  }\n  return offsets[index];\n}\nfunction updateOffset(offsets, base, span, value) {\n  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);\n}\n\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString(tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n  }\n  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);\n    while (y < rowsInThisColumn) {\n      cell = layout[x][y];\n      if (cell) {\n        if (!cell.rendered) {\n          let cellWidth = 0;\n          for (let j = 0; j < cell.lines.length; j++) {\n            const line = cell.lines[j];\n            const lineOffset = rowOffsets[y] + j;\n            outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n            cellWidth = line.length > cellWidth ? line.length : cellWidth;\n          }\n          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n          cell.rendered = true;\n        }\n        y += cell.rowspan;\n      } else {\n        const lineOffset = rowOffsets[y];\n        outputLines[lineOffset] = outputLines[lineOffset] || '';\n        y++;\n      }\n    }\n  }\n  return outputLines.join('\\n');\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak(elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr(elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, '\\n') : str).split('\\n').map(line => '> ' + line).join('\\n')\n  });\n}\nfunction withBrackets(str, brackets) {\n  if (!brackets) {\n    return str;\n  }\n  const lbr = typeof brackets[0] === 'string' ? brackets[0] : '[';\n  const rbr = typeof brackets[1] === 'string' ? brackets[1] : ']';\n  return lbr + str + rbr;\n}\nfunction pathRewrite(path, rewriter, baseUrl, metadata, elem) {\n  const modifiedPath = typeof rewriter === 'function' ? rewriter(path, metadata, elem) : path;\n  return modifiedPath[0] === '/' && baseUrl ? trimCharacterEnd(baseUrl, '/') + modifiedPath : modifiedPath;\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage(elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = attribs.alt ? attribs.alt : '';\n  const src = !attribs.src ? '' : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n  const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);\n  builder.addInline(text, {\n    noWordTransform: true\n  });\n}\n\n// a img baseUrl\n// a img pathRewrite\n// a img linkBrackets\n\n// a     ignoreHref: false\n//            ignoreText ?\n// a     noAnchorUrl: true\n//            can be replaced with selector\n// a     hideLinkHrefIfSameAsText: false\n//            how to compare, what to show (text, href, normalized) ?\n// a     mailto protocol removed without options\n\n// a     protocols: mailto, tel, ...\n//            can be matched with selector?\n\n// anchors, protocols - only if no pathRewrite fn is provided\n\n// normalize-url ?\n\n// a\n// a[href^=\"#\"] - format:skip by default\n// a[href^=\"mailto:\"] - ?\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor(elem, walk, builder, formatOptions) {\n  function getHref() {\n    if (formatOptions.ignoreHref) {\n      return '';\n    }\n    if (!elem.attribs || !elem.attribs.href) {\n      return '';\n    }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') {\n      return '';\n    }\n    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    return href;\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(str => {\n      if (str) {\n        text += str;\n      }\n      return str;\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(!text ? href : ' ' + withBrackets(href, formatOptions.linkBrackets), {\n        noWordTransform: true\n      });\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */\nfunction formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || []\n  // it might be more accurate to check only for html spaces here, but no significant benefit\n  ).filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data)).map(function (child) {\n    if (child.name !== 'li') {\n      return {\n        node: child,\n        prefix: ''\n      };\n    }\n    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n    if (prefix.length > maxPrefixLength) {\n      maxPrefixLength = prefix.length;\n    }\n    return {\n      node: child,\n      prefix: prefix\n    };\n  });\n  if (!listItems.length) {\n    return;\n  }\n  builder.openList({\n    interRowLineBreaks: 1,\n    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,\n    maxPrefixLength: maxPrefixLength,\n    prefixAlign: 'left'\n  });\n  for (const {\n    node,\n    prefix\n  } of listItems) {\n    builder.openListItem({\n      prefix: prefix\n    });\n    walk([node], builder);\n    builder.closeListItem();\n  }\n  builder.closeList({\n    trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList(elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList(elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction() {\n  let olType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1';\n  switch (olType) {\n    case 'a':\n      return i => numberToLetterSequence(i, 'a');\n    case 'A':\n      return i => numberToLetterSequence(i, 'A');\n    case 'i':\n      return i => numberToRoman(i).toLowerCase();\n    case 'I':\n      return i => numberToRoman(i);\n    case '1':\n    default:\n      return i => i.toString();\n  }\n}\n\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */\nfunction splitClassesAndIds(selectors) {\n  const classes = [];\n  const ids = [];\n  for (const selector of selectors) {\n    if (selector.startsWith('.')) {\n      classes.push(selector.substring(1));\n    } else if (selector.startsWith('#')) {\n      ids.push(selector.substring(1));\n    }\n  }\n  return {\n    classes: classes,\n    ids: ids\n  };\n}\nfunction isDataTable(attr, tables) {\n  if (tables === true) {\n    return true;\n  }\n  if (!attr) {\n    return false;\n  }\n  const {\n    classes,\n    ids\n  } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable(elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\nfunction formatBlock(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable(elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    tableToString: rows => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n  function formatCell(cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({\n      maxColumnWidth: formatOptions.maxColumnWidth\n    });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({\n      colspan: colspan,\n      rowspan: rowspan\n    });\n  }\n  function walkTable(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? cellNode => {\n      builder.pushWordTransform(str => str.toUpperCase());\n      formatCell(cellNode);\n      builder.popWordTransform();\n    } : formatCell;\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n      case 'tr':\n        {\n          builder.openTableRow();\n          for (const childOfTr of elem.children) {\n            if (childOfTr.type !== 'tag') {\n              continue;\n            }\n            switch (childOfTr.name) {\n              case 'th':\n                {\n                  formatHeaderCell(childOfTr);\n                  break;\n                }\n              case 'td':\n                {\n                  formatCell(childOfTr);\n                  break;\n                }\n              // do nothing\n            }\n          }\n          builder.closeTableRow();\n          break;\n        }\n      // do nothing\n    }\n  }\n}\nvar textFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  anchor: formatAnchor,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n});\n\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\nconst DEFAULT_OPTIONS = {\n  baseElements: {\n    selectors: ['body'],\n    orderBy: 'selectors',\n    // 'selectors' | 'occurrence'\n    returnDomByDefault: true\n  },\n  decodeEntities: true,\n  encodeCharacters: {},\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxBaseElements: undefined,\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: 1 << 24 // 16_777_216\n  },\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  selectors: [{\n    selector: '*',\n    format: 'inline'\n  }, {\n    selector: 'a',\n    format: 'anchor',\n    options: {\n      baseUrl: null,\n      hideLinkHrefIfSameAsText: false,\n      ignoreHref: false,\n      linkBrackets: ['[', ']'],\n      noAnchorUrl: true\n    }\n  }, {\n    selector: 'article',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'aside',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'blockquote',\n    format: 'blockquote',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      trimEmptyLines: true\n    }\n  }, {\n    selector: 'br',\n    format: 'lineBreak'\n  }, {\n    selector: 'div',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'footer',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'form',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'h1',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h2',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h3',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 3,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h4',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h5',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'h6',\n    format: 'heading',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2,\n      uppercase: true\n    }\n  }, {\n    selector: 'header',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'hr',\n    format: 'horizontalLine',\n    options: {\n      leadingLineBreaks: 2,\n      length: undefined,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'img',\n    format: 'image',\n    options: {\n      baseUrl: null,\n      linkBrackets: ['[', ']']\n    }\n  }, {\n    selector: 'main',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'nav',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'ol',\n    format: 'orderedList',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'p',\n    format: 'paragraph',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'pre',\n    format: 'pre',\n    options: {\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'section',\n    format: 'block',\n    options: {\n      leadingLineBreaks: 1,\n      trailingLineBreaks: 1\n    }\n  }, {\n    selector: 'table',\n    format: 'table',\n    options: {\n      colSpacing: 3,\n      leadingLineBreaks: 2,\n      maxColumnWidth: 60,\n      rowSpacing: 0,\n      trailingLineBreaks: 2,\n      uppercaseHeaderCells: true\n    }\n  }, {\n    selector: 'ul',\n    format: 'unorderedList',\n    options: {\n      itemPrefix: ' * ',\n      leadingLineBreaks: 2,\n      trailingLineBreaks: 2\n    }\n  }, {\n    selector: 'wbr',\n    format: 'wbr'\n  }],\n  tables: [],\n  // deprecated\n  whitespaceCharacters: ' \\t\\r\\n\\f\\u200b',\n  wordwrap: 80\n};\nconst concatMerge = (acc, src, options) => [...acc, ...src];\nconst overwriteMerge = (acc, src, options) => [...src];\nconst selectorsMerge = (acc, src, options) => acc.some(s => typeof s === 'object') ? concatMerge(acc, src) // selectors\n: overwriteMerge(acc, src) // baseElements.selectors\n;\n\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  options = merge(DEFAULT_OPTIONS, options, {\n    arrayMerge: overwriteMerge,\n    customMerge: key => key === 'selectors' ? selectorsMerge : undefined\n  });\n  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n  options.selectors = mergeDuplicatesPreferLast(options.selectors, s => s.selector);\n  handleDeprecatedOptions(options);\n  return compile$1(options);\n}\n\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\nfunction convert(html) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  return compile(options)(html, metadata);\n}\n\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\nfunction handleDeprecatedOptions(options) {\n  if (options.tags) {\n    const tagDefinitions = Object.entries(options.tags).map(_ref6 => {\n      let [selector, definition] = _ref6;\n      return {\n        ...definition,\n        selector: selector || '*'\n      };\n    });\n    options.selectors.push(...tagDefinitions);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, s => s.selector);\n  }\n  function set(obj, path, value) {\n    const valueKey = path.pop();\n    for (const key of path) {\n      let nested = obj[key];\n      if (!nested) {\n        nested = {};\n        obj[key] = nested;\n      }\n      obj = nested;\n    }\n    obj[valueKey] = value;\n  }\n  if (options['baseElement']) {\n    const baseElement = options['baseElement'];\n    set(options, ['baseElements', 'selectors'], Array.isArray(baseElement) ? baseElement : [baseElement]);\n  }\n  if (options['returnDomByDefault'] !== undefined) {\n    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);\n  }\n  for (const definition of options.selectors) {\n    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {\n      set(definition, ['options', 'linkBrackets'], false);\n    }\n  }\n}\nexport { compile, convert, convert as htmlToText };","map":{"version":3,"names":["hp2Builder","parseDocument","DecisionTree","merge","render","limitedDepthRecursive","n","f","g","arguments","length","undefined","f1","_len","args","Array","_key","_len2","_key2","trimCharacter","str","char","start","end","substring","trimCharacterEnd","unicodeEscape","replace","c","charCodeAt","toString","padStart","mergeDuplicatesPreferLast","items","getKey","map","Map","i","item","key","set","has","get","arrayMerge","overwriteMerge$1","values","reverse","acc","src","options","obj","path","numberToLetterSequence","num","baseChar","base","digits","push","baseCode","String","fromCharCode","join","I","V","numberToRoman","v","repeat","InlineTextBuilder","constructor","maxLineLength","lines","nextLineWords","wordwrap","Number","MAX_VALUE","nextLineAvailableChars","wrapCharacters","forceWrapOnLimit","stashedSpace","wordBreakOpportunity","pushWord","word","noWrap","startNewLine","isLineStart","cost","first","rest","splitLongWord","part","popWord","lastWord","pop","concatWord","concat","from","isEmpty","clear","words","parts","idx","firstLine","remainingChars","splitIndex","lastIndexOf","StackItem","next","getRoot","BlockStackItem","leadingLineBreaks","inlineTextBuilder","rawText","stashedLineBreaks","isPre","isNoWrap","ListStackItem","interRowLineBreaks","maxPrefixLength","prefixAlign","ListItemStackItem","prefix","TableStackItem","rows","TableRowStackItem","cells","TableCellStackItem","maxColumnWidth","TransformerStackItem","transform","charactersToCodes","WhitespaceProcessor","whitespaceChars","preserveNewlines","whitespaceCharacters","whitespaceCodes","leadingWhitespaceRe","RegExp","trailingWhitespaceRe","allWhitespaceOrEmptyRe","newlineOrNonWhitespaceRe","newlineOrNonNewlineStringRe","wordOrNewlineRe","shrinkWrapAdd","text","previouslyStashedSpace","anyMatch","m","exec","testLeadingWhitespace","testTrailingWhitespace","wordRe","addLiteral","test","testContainsWords","countNewlinesNoWords","lastIndex","counter","match","BlockTextBuilder","picker","metadata","whitespaceProcessor","_stackItem","_wordTransformer","pushWordTransform","wordTransform","popWordTransform","startNoWrap","stopNoWrap","_getCombinedWordTransformer","wt","applyTransformer","ce","encodeCharacters","_popStackItem","addLineBreak","addWordBreakOpportunity","addInline","noWordTransform","newlinesNumber","openBlock","reservedLineLength","Math","max","closeBlock","trailingLineBreaks","blockTransform","block","blockText","getText","addText","openList","openListItem","Error","list","prefixLength","closeListItem","listItem","spacing","padEnd","closeList","openTable","openTableRow","openTableCell","closeTableCell","colspan","rowspan","cell","closeTableRow","row","closeTable","_ref","tableToString","table","output","stackItem","parentText","lineBreaks","transformer","compile$1","selectorsWithoutFormat","selectors","filter","s","format","selector","build","makeReplacerFromDict","baseSelectorsPicker","baseElements","findBaseElements","dom","findBases","limitedWalk","limits","maxDepth","recursiveWalk","builder","ellipsis","html","process","walk","maxInputLength","console","warn","document","decodeEntities","bases","children","results","slice","maxChildNodes","elem","type","pickedSelectorIndex","pick1","selectorIndex","element","maxBaseElements","orderBy","sort","a","b","returnDomByDefault","x","tooManyChildNodes","data","tagDefinition","formatters","dict","Object","keys","entries","_ref2","regex","_ref3","_ref4","replacer","_len3","cgs","_key3","findIndex","cg","formatSkip","formatOptions","formatInlineString","string","formatBlockString","formatInline","formatBlock$1","renderOpenTag","attrs","attribs","_ref5","k","name","renderCloseTag","formatInlineTag","formatBlockTag","formatInlineHtml","formatBlockHtml","formatInlineSurround","suffix","genericFormatters","freeze","__proto__","blockHtml","blockString","blockTag","inline","inlineHtml","inlineString","inlineSurround","inlineTag","skip","getRow","matrix","j","findFirstVacantIndex","transposeInPlace","maxSize","rowI","rowJ","temp","putCellIntoLayout","layout","baseRow","baseCol","r","layoutRow","getOrInitOffset","offsets","index","updateOffset","span","value","tableRows","rowSpacing","colSpacing","colNumber","rowNumber","rowOffsets","split","cellHeight","outputLines","colOffsets","y","rowsInThisColumn","min","rendered","cellWidth","line","lineOffset","formatLineBreak","formatWbr","formatHorizontalLine","formatParagraph","formatPre","formatHeading","uppercase","toUpperCase","formatBlockquote","trimEmptyLines","withBrackets","brackets","lbr","rbr","pathRewrite","rewriter","baseUrl","modifiedPath","formatImage","alt","linkBrackets","formatAnchor","getHref","ignoreHref","href","noAnchorUrl","hideSameLink","hideLinkHrefIfSameAsText","formatList","nextPrefixCallback","isNestedList","listItems","child","node","trimStart","formatUnorderedList","itemPrefix","formatOrderedList","nextIndex","indexFunction","getOrderedListIndexFunction","olType","toLowerCase","splitClassesAndIds","classes","ids","startsWith","isDataTable","attr","tables","attrClasses","attrIds","some","includes","formatTable","formatDataTable","formatBlock","forEach","walkTable","formatCell","cellNode","formatHeaderCell","uppercaseHeaderCells","childOfTr","textFormatters","anchor","blockquote","dataTable","heading","horizontalLine","image","lineBreak","orderedList","paragraph","pre","unorderedList","wbr","DEFAULT_OPTIONS","longWordSplit","concatMerge","overwriteMerge","selectorsMerge","compile","customMerge","assign","handleDeprecatedOptions","convert","tags","tagDefinitions","_ref6","definition","valueKey","nested","baseElement","isArray","htmlToText"],"sources":["F:/scandiweb_store/frontend/node_modules/html-to-text/lib/html-to-text.mjs"],"sourcesContent":["import { hp2Builder } from '@selderee/plugin-htmlparser2';\nimport { parseDocument } from 'htmlparser2';\nimport { DecisionTree } from 'selderee';\nimport merge from 'deepmerge';\nimport { render } from 'dom-serializer';\n\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */\nfunction limitedDepthRecursive (n, f, g = () => undefined) {\n  if (n === undefined) {\n    const f1 = function (...args) { return f(f1, ...args); };\n    return f1;\n  }\n  if (n >= 0) {\n    return function (...args) { return f(limitedDepthRecursive(n - 1, f, g), ...args); };\n  }\n  return g;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacter (str, char) {\n  let start = 0;\n  let end = str.length;\n  while (start < end && str[start] === char) { ++start; }\n  while (end > start && str[end - 1] === char) { --end; }\n  return (start > 0 || end < str.length)\n    ? str.substring(start, end)\n    : str;\n}\n\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */\nfunction trimCharacterEnd (str, char) {\n  let end = str.length;\n  while (end > 0 && str[end - 1] === char) { --end; }\n  return (end < str.length)\n    ? str.substring(0, end)\n    : str;\n}\n\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */\nfunction unicodeEscape (str) {\n  return str.replace(/[\\s\\S]/g, c => '\\\\u' + c.charCodeAt().toString(16).padStart(4, '0'));\n}\n\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */\nfunction mergeDuplicatesPreferLast (items, getKey) {\n  const map = new Map();\n  for (let i = items.length; i-- > 0;) {\n    const item = items[i];\n    const key = getKey(item);\n    map.set(\n      key,\n      (map.has(key))\n        ? merge(item, map.get(key), { arrayMerge: overwriteMerge$1 })\n        : item\n    );\n  }\n  return [...map.values()].reverse();\n}\n\nconst overwriteMerge$1 = (acc, src, options) => [...src];\n\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */\nfunction get (obj, path) {\n  for (const key of path) {\n    if (!obj) { return undefined; }\n    obj = obj[key];\n  }\n  return obj;\n}\n\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */\nfunction numberToLetterSequence (num, baseChar = 'a', base = 26) {\n  const digits = [];\n  do {\n    num -= 1;\n    digits.push(num % base);\n    num = (num / base) >> 0; // quick `floor`\n  } while (num > 0);\n  const baseCode = baseChar.charCodeAt(0);\n  return digits\n    .reverse()\n    .map(n => String.fromCharCode(baseCode + n))\n    .join('');\n}\n\nconst I = ['I', 'X', 'C', 'M'];\nconst V = ['V', 'L', 'D'];\n\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */\nfunction numberToRoman (num) {\n  return [...(num) + '']\n    .map(n => +n)\n    .reverse()\n    .map((v, i) => ((v % 5 < 4)\n      ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)\n      : I[i] + (v < 5 ? V[i] : I[i + 1])))\n    .reverse()\n    .join('');\n}\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor (options, maxLineLength = undefined) {\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];\n    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;\n\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  pushWord (word, noWrap = false) {\n    if (this.nextLineAvailableChars <= 0 && !noWrap) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if ((cost <= this.nextLineAvailableChars) || noWrap) { // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n\n    } else { // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) { this.startNewLine(); }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord () {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */\n  concatWord (word, noWrap = false) {\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word, noWrap);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord((lastWord) ? lastWord.concat(word) : word, noWrap);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine (n = 1) {\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({ length: n - 1 }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty () {\n    return this.lines.length === 0\n        && this.nextLineWords.length === 0;\n  }\n\n  clear () {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return [...this.lines, this.nextLineWords]\n      .map(words => words.join(' '))\n      .join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord (word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n\n      if (splitIndex > -1) { // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n\n      } else { // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) { // There is next character to try\n\n          word = firstLine + remainingChars;\n\n        } else { // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n\n        }\n\n      }\n\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\n\n/* eslint-disable max-classes-per-file */\n\n\nclass StackItem {\n  constructor (next = null) { this.next = next; }\n\n  getRoot () { return (this.next) ? this.next : this; }\n}\n\nclass BlockStackItem extends StackItem {\n  constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {\n    super(next);\n    this.leadingLineBreaks = leadingLineBreaks;\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass ListStackItem extends BlockStackItem {\n  constructor (\n    options,\n    next = null,\n    {\n      interRowLineBreaks = 1,\n      leadingLineBreaks = 2,\n      maxLineLength = undefined,\n      maxPrefixLength = 0,\n      prefixAlign = 'left',\n    } = {}\n  ) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.maxPrefixLength = maxPrefixLength;\n    this.prefixAlign = prefixAlign;\n    this.interRowLineBreaks = interRowLineBreaks;\n  }\n}\n\nclass ListItemStackItem extends BlockStackItem {\n  constructor (\n    options,\n    next = null,\n    {\n      leadingLineBreaks = 1,\n      maxLineLength = undefined,\n      prefix = '',\n    } = {}\n  ) {\n    super(options, next, leadingLineBreaks, maxLineLength);\n    this.prefix = prefix;\n  }\n}\n\nclass TableStackItem extends StackItem {\n  constructor (next = null) {\n    super(next);\n    this.rows = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TableRowStackItem extends StackItem {\n  constructor (next = null) {\n    super(next);\n    this.cells = [];\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TableCellStackItem extends StackItem {\n  constructor (options, next = null, maxColumnWidth = undefined) {\n    super(next);\n    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n    this.rawText = '';\n    this.stashedLineBreaks = 0;\n    this.isPre = next && next.isPre;\n    this.isNoWrap = next && next.isNoWrap;\n  }\n}\n\nclass TransformerStackItem extends StackItem {\n  constructor (next = null, transform) {\n    super(next);\n    this.transform = transform;\n  }\n}\n\nfunction charactersToCodes (str) {\n  return [...str]\n    .map(c => '\\\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))\n    .join('');\n}\n\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */\nclass WhitespaceProcessor {\n\n  /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */\n  constructor (options) {\n    this.whitespaceChars = (options.preserveNewlines)\n      ? options.whitespaceCharacters.replace(/\\n/g, '')\n      : options.whitespaceCharacters;\n    const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n    this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, 'g');\n    this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, 'g');\n\n    if (options.preserveNewlines) {\n\n      const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, 'gm');\n\n      /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordOrNewlineRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (m[0] === '\\n') {\n            inlineTextBuilder.startNewLine();\n          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordOrNewlineRe.exec(text)) !== null) {\n            if (m[0] === '\\n') {\n              inlineTextBuilder.startNewLine();\n            } else {\n              inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n            }\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));\n        // No need to stash a space in case last added item was a new line,\n        // but that won't affect anything later anyway.\n      };\n\n    } else {\n\n      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');\n\n      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {\n        if (!text) { return; }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = wordRe.exec(text);\n        if (m) {\n          anyMatch = true;\n          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          } else {\n            inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n          }\n          while ((m = wordRe.exec(text)) !== null) {\n            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n          }\n        }\n        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);\n      };\n\n    }\n  }\n\n  /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */\n  addLiteral (text, inlineTextBuilder, noWrap = true) {\n    if (!text) { return; }\n    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n    let anyMatch = false;\n    let m = this.newlineOrNonNewlineStringRe.exec(text);\n    if (m) {\n      anyMatch = true;\n      if (m[0] === '\\n') {\n        inlineTextBuilder.startNewLine();\n      } else if (previouslyStashedSpace) {\n        inlineTextBuilder.pushWord(m[0], noWrap);\n      } else {\n        inlineTextBuilder.concatWord(m[0], noWrap);\n      }\n      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {\n        if (m[0] === '\\n') {\n          inlineTextBuilder.startNewLine();\n        } else {\n          inlineTextBuilder.pushWord(m[0], noWrap);\n        }\n      }\n    }\n    inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch);\n  }\n\n  /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testLeadingWhitespace (text) {\n    return this.leadingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testTrailingWhitespace (text) {\n    return this.trailingWhitespaceRe.test(text);\n  }\n\n  /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */\n  testContainsWords (text) {\n    return !this.allWhitespaceOrEmptyRe.test(text);\n  }\n\n  /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */\n  countNewlinesNoWords (text) {\n    this.newlineOrNonWhitespaceRe.lastIndex = 0;\n    let counter = 0;\n    let match;\n    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {\n      if (match[0] === '\\n') {\n        counter++;\n      } else {\n        return 0;\n      }\n    }\n    return counter;\n  }\n\n}\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */\n  constructor (options, picker, metadata = undefined) {\n    this.options = options;\n    this.picker = picker;\n    this.metadata = metadata;\n    this.whitespaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */\n  startNoWrap () {\n    this._stackItem.isNoWrap = true;\n  }\n\n  /**\n   * Return automatic wrapping to behavior defined by options.\n   */\n  stopNoWrap () {\n    this._stackItem.isNoWrap = false;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const wt = (this._wordTransformer)\n      ? ((str) => applyTransformer(str, this._wordTransformer))\n      : undefined;\n    const ce = this.options.encodeCharacters;\n    return (wt)\n      ? ((ce) ? (str) => ce(wt(str)) : wt)\n      : ce;\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */\n  addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      str.length === 0 || // empty string\n      (\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n      )\n    ) { return; }\n\n    if (this.options.preserveNewlines) {\n      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n      if (newlinesNumber > 0) {\n        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n        // keep stashedLineBreaks unchanged\n        return;\n      }\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.shrinkWrapAdd(\n      str,\n      this._stackItem.inlineTextBuilder,\n      (noWordTransform) ? undefined : this._getCombinedWordTransformer(),\n      this._stackItem.isNoWrap\n    );\n    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n  }\n\n  /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */\n  addLiteral (str) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof ListItemStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (str.length === 0) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (this._stackItem.stashedLineBreaks) {\n      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n    }\n    this.whitespaceProcessor.addLiteral(\n      str,\n      this._stackItem.inlineTextBuilder,\n      this._stackItem.isNoWrap\n    );\n    this._stackItem.stashedLineBreaks = 0;\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */\n  openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */\n  closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */\n  openList ({ maxPrefixLength = 0, prefixAlign = 'left', interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {\n    this._stackItem = new ListStackItem(this.options, this._stackItem, {\n      interRowLineBreaks: interRowLineBreaks,\n      leadingLineBreaks: leadingLineBreaks,\n      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n      maxPrefixLength: maxPrefixLength,\n      prefixAlign: prefixAlign\n    });\n  }\n\n  /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */\n  openListItem ({ prefix = '' } = {}) {\n    if (!(this._stackItem instanceof ListStackItem)) {\n      throw new Error('Can\\'t add a list item to something that is not a list! Check the formatter.');\n    }\n    const list = this._stackItem;\n    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n    this._stackItem = new ListItemStackItem(this.options, list, {\n      prefix: prefix,\n      maxLineLength: maxLineLength,\n      leadingLineBreaks: list.interRowLineBreaks\n    });\n  }\n\n  /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */\n  closeListItem () {\n    const listItem = this._popStackItem();\n    const list = listItem.next;\n\n    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n    const spacing = '\\n' + ' '.repeat(prefixLength);\n    const prefix = (list.prefixAlign === 'right')\n      ? listItem.prefix.padStart(prefixLength)\n      : listItem.prefix.padEnd(prefixLength);\n    const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n\n    addText(\n      list,\n      text,\n      listItem.leadingLineBreaks,\n      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)\n    );\n  }\n\n  /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */\n  closeList ({ trailingLineBreaks = 2 } = {}) {\n    const list = this._popStackItem();\n    const text = getText(list);\n    if (text) {\n      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add a table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add a table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */\n  closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */\n  closeTable ({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof ListItemStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks, list items and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof ListItemStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks, list items and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */\nfunction applyTransformer (str, transformer) {\n  return ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n}\n\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile$1 (options = {}) {\n  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);\n  if (selectorsWithoutFormat.length) {\n    throw new Error(\n      'Following selectors have no specified format: ' +\n      selectorsWithoutFormat.map(s => `\\`${s.selector}\\``).join(', ')\n    );\n  }\n  const picker = new DecisionTree(\n    options.selectors.map(s => [s.selector, s])\n  ).build(hp2Builder);\n\n  if (typeof options.encodeCharacters !== 'function') {\n    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n  }\n\n  const baseSelectorsPicker = new DecisionTree(\n    options.baseElements.selectors.map((s, i) => [s, i + 1])\n  ).build(hp2Builder);\n  function findBaseElements (dom) {\n    return findBases(dom, options, baseSelectorsPicker);\n  }\n\n  const limitedWalk = limitedDepthRecursive(\n    options.limits.maxDepth,\n    recursiveWalk,\n    function (dom, builder) {\n      builder.addInline(options.limits.ellipsis || '');\n    }\n  );\n\n  return function (html, metadata = undefined) {\n    return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n  };\n}\n\n\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */\nfunction process (html, metadata, options, picker, findBaseElements, walk) {\n  const maxInputLength = options.limits.maxInputLength;\n  if (maxInputLength && html && html.length > maxInputLength) {\n    console.warn(\n      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`\n    );\n    html = html.substring(0, maxInputLength);\n  }\n\n  const document = parseDocument(html, { decodeEntities: options.decodeEntities });\n  const bases = findBaseElements(document.children);\n  const builder = new BlockTextBuilder(options, picker, metadata);\n  walk(bases, builder);\n  return builder.toString();\n}\n\n\nfunction findBases (dom, options, baseSelectorsPicker) {\n  const results = [];\n\n  function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    for (const elem of dom) {\n      if (elem.type !== 'tag') {\n        continue;\n      }\n      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n      if (pickedSelectorIndex > 0) {\n        results.push({ selectorIndex: pickedSelectorIndex, element: elem });\n      } else if (elem.children) {\n        walk(elem.children);\n      }\n      if (results.length >= options.limits.maxBaseElements) {\n        return;\n      }\n    }\n  }\n\n  const limitedWalk = limitedDepthRecursive(\n    options.limits.maxDepth,\n    recursiveWalk\n  );\n  limitedWalk(dom);\n\n  if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'\n    results.sort((a, b) => a.selectorIndex - b.selectorIndex);\n  }\n  return (options.baseElements.returnDomByDefault && results.length === 0)\n    ? dom\n    : results.map(x => x.element);\n}\n\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */\nfunction recursiveWalk (walk, dom, builder) {\n  if (!dom) { return; }\n\n  const options = builder.options;\n\n  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n  if (tooManyChildNodes) {\n    dom = dom.slice(0, options.limits.maxChildNodes);\n    dom.push({\n      data: options.limits.ellipsis,\n      type: 'text'\n    });\n  }\n\n  for (const elem of dom) {\n    switch (elem.type) {\n      case 'text': {\n        builder.addInline(elem.data);\n        break;\n      }\n      case 'tag': {\n        const tagDefinition = builder.picker.pick1(elem);\n        const format = options.formatters[tagDefinition.format];\n        format(elem, walk, builder, tagDefinition.options || {});\n        break;\n      }\n    }\n  }\n\n  return;\n}\n\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */\nfunction makeReplacerFromDict (dict) {\n  if (!dict || Object.keys(dict).length === 0) {\n    return undefined;\n  }\n  /** @type { [string, string][] } */\n  const entries = Object.entries(dict).filter(([, v]) => v !== false);\n  const regex = new RegExp(\n    entries\n      .map(([c]) => `(${unicodeEscape([...c][0])})`)\n      .join('|'),\n    'g'\n  );\n  const values = entries.map(([, v]) => v);\n  const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];\n  return (str) => str.replace(regex, replacer);\n}\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip (elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineString (elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.string || '');\n}\n\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockString (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addLiteral(formatOptions.string || '');\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline (elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock$1 (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\nfunction renderOpenTag (elem) {\n  const attrs = (elem.attribs && elem.attribs.length)\n    ? ' ' + Object.entries(elem.attribs)\n      .map(([k, v]) => ((v === '') ? k : `${k}=${v.replace(/\"/g, '&quot;')}`))\n      .join(' ')\n    : '';\n  return `<${elem.name}${attrs}>`;\n}\n\nfunction renderCloseTag (elem) {\n  return `</${elem.name}>`;\n}\n\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineTag (elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockTag (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.startNoWrap();\n  builder.addLiteral(renderOpenTag(elem));\n  builder.stopNoWrap();\n  walk(elem.children, builder);\n  builder.startNoWrap();\n  builder.addLiteral(renderCloseTag(elem));\n  builder.stopNoWrap();\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineHtml (elem, walk, builder, formatOptions) {\n  builder.startNoWrap();\n  builder.addLiteral(\n    render(elem, { decodeEntities: builder.options.decodeEntities })\n  );\n  builder.stopNoWrap();\n}\n\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockHtml (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.startNoWrap();\n  builder.addLiteral(\n    render(elem, { decodeEntities: builder.options.decodeEntities })\n  );\n  builder.stopNoWrap();\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */\nfunction formatInlineSurround (elem, walk, builder, formatOptions) {\n  builder.addLiteral(formatOptions.prefix || '');\n  walk(elem.children, builder);\n  builder.addLiteral(formatOptions.suffix || '');\n}\n\nvar genericFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  block: formatBlock$1,\n  blockHtml: formatBlockHtml,\n  blockString: formatBlockString,\n  blockTag: formatBlockTag,\n  inline: formatInline,\n  inlineHtml: formatInlineHtml,\n  inlineString: formatInlineString,\n  inlineSurround: formatInlineSurround,\n  inlineTag: formatInlineTag,\n  skip: formatSkip\n});\n\nfunction getRow (matrix, j) {\n  if (!matrix[j]) { matrix[j] = []; }\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex (row, x = 0) {\n  while (row[x]) { x++; }\n  return x;\n}\n\nfunction transposeInPlace (matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      if (rowI[j] || rowJ[i]) {\n        const temp = rowI[j];\n        rowI[j] = rowJ[i];\n        rowJ[i] = temp;\n      }\n    }\n  }\n}\n\nfunction putCellIntoLayout (cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction getOrInitOffset (offsets, index) {\n  if (offsets[index] === undefined) {\n    offsets[index] = (index === 0) ? 0 : 1 + getOrInitOffset(offsets, index - 1);\n  }\n  return offsets[index];\n}\n\nfunction updateOffset (offsets, base, span, value) {\n  offsets[base + span] = Math.max(\n    getOrInitOffset(offsets, base + span),\n    getOrInitOffset(offsets, base) + value\n  );\n}\n\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString (tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);\n\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);\n    while (y < rowsInThisColumn) {\n      cell = layout[x][y];\n      if (cell) {\n        if (!cell.rendered) {\n          let cellWidth = 0;\n          for (let j = 0; j < cell.lines.length; j++) {\n            const line = cell.lines[j];\n            const lineOffset = rowOffsets[y] + j;\n            outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n            cellWidth = (line.length > cellWidth) ? line.length : cellWidth;\n          }\n          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n          cell.rendered = true;\n        }\n        y += cell.rowspan;\n      } else {\n        const lineOffset = rowOffsets[y];\n        outputLines[lineOffset] = (outputLines[lineOffset] || '');\n        y++;\n      }\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak (elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr (elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\\n') : str)\n      .split('\\n')\n      .map(line => '> ' + line)\n      .join('\\n')\n  });\n}\n\nfunction withBrackets (str, brackets) {\n  if (!brackets) { return str; }\n\n  const lbr = (typeof brackets[0] === 'string')\n    ? brackets[0]\n    : '[';\n  const rbr = (typeof brackets[1] === 'string')\n    ? brackets[1]\n    : ']';\n  return lbr + str + rbr;\n}\n\nfunction pathRewrite (path, rewriter, baseUrl, metadata, elem) {\n  const modifiedPath = (typeof rewriter === 'function')\n    ? rewriter(path, metadata, elem)\n    : path;\n  return (modifiedPath[0] === '/' && baseUrl)\n    ? trimCharacterEnd(baseUrl, '/') + modifiedPath\n    : modifiedPath;\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage (elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = (attribs.alt)\n    ? attribs.alt\n    : '';\n  const src = (!attribs.src)\n    ? ''\n    : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n  const text = (!src)\n    ? alt\n    : (!alt)\n      ? withBrackets(src, formatOptions.linkBrackets)\n      : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);\n\n  builder.addInline(text, { noWordTransform: true });\n}\n\n// a img baseUrl\n// a img pathRewrite\n// a img linkBrackets\n\n// a     ignoreHref: false\n//            ignoreText ?\n// a     noAnchorUrl: true\n//            can be replaced with selector\n// a     hideLinkHrefIfSameAsText: false\n//            how to compare, what to show (text, href, normalized) ?\n// a     mailto protocol removed without options\n\n// a     protocols: mailto, tel, ...\n//            can be matched with selector?\n\n// anchors, protocols - only if no pathRewrite fn is provided\n\n// normalize-url ?\n\n// a\n// a[href^=\"#\"] - format:skip by default\n// a[href^=\"mailto:\"] - ?\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor (elem, walk, builder, formatOptions) {\n  function getHref () {\n    if (formatOptions.ignoreHref) { return ''; }\n    if (!elem.attribs || !elem.attribs.href) { return ''; }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }\n    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    return href;\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(\n      str => {\n        if (str) { text += str; }\n        return str;\n      }\n    );\n    walk(elem.children, builder);\n    builder.popWordTransform();\n\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(\n        (!text)\n          ? href\n          : ' ' + withBrackets(href, formatOptions.linkBrackets),\n        { noWordTransform: true }\n      );\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */\nfunction formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || [])\n    // it might be more accurate to check only for html spaces here, but no significant benefit\n    .filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data))\n    .map(function (child) {\n      if (child.name !== 'li') {\n        return { node: child, prefix: '' };\n      }\n      const prefix = (isNestedList)\n        ? nextPrefixCallback().trimStart()\n        : nextPrefixCallback();\n      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }\n      return { node: child, prefix: prefix };\n    });\n  if (!listItems.length) { return; }\n\n  builder.openList({\n    interRowLineBreaks: 1,\n    leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2),\n    maxPrefixLength: maxPrefixLength,\n    prefixAlign: 'left'\n  });\n\n  for (const { node, prefix } of listItems) {\n    builder.openListItem({ prefix: prefix });\n    walk([node], builder);\n    builder.closeListItem();\n  }\n\n  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList (elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList (elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction (olType = '1') {\n  switch (olType) {\n    case 'a': return (i) => numberToLetterSequence(i, 'a');\n    case 'A': return (i) => numberToLetterSequence(i, 'A');\n    case 'i': return (i) => numberToRoman(i).toLowerCase();\n    case 'I': return (i) => numberToRoman(i);\n    case '1':\n    default: return (i) => (i).toString();\n  }\n}\n\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */\nfunction splitClassesAndIds (selectors) {\n  const classes = [];\n  const ids = [];\n  for (const selector of selectors) {\n    if (selector.startsWith('.')) {\n      classes.push(selector.substring(1));\n    } else if (selector.startsWith('#')) {\n      ids.push(selector.substring(1));\n    }\n  }\n  return { classes: classes, ids: ids };\n}\n\nfunction isDataTable (attr, tables) {\n  if (tables === true) { return true; }\n  if (!attr) { return false; }\n\n  const { classes, ids } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable (elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables)\n    ? formatDataTable(elem, walk, builder, formatOptions)\n    : formatBlock(elem, walk, builder, formatOptions);\n}\n\nfunction formatBlock (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable (elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell (cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });\n  }\n\n  function walkTable (elem) {\n    if (elem.type !== 'tag') { return; }\n\n    const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)\n      ? (cellNode) => {\n        builder.pushWordTransform(str => str.toUpperCase());\n        formatCell(cellNode);\n        builder.popWordTransform();\n      }\n      : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr': {\n        builder.openTableRow();\n        for (const childOfTr of elem.children) {\n          if (childOfTr.type !== 'tag') { continue; }\n          switch (childOfTr.name) {\n            case 'th': {\n              formatHeaderCell(childOfTr);\n              break;\n            }\n            case 'td': {\n              formatCell(childOfTr);\n              break;\n            }\n              // do nothing\n          }\n        }\n        builder.closeTableRow();\n        break;\n      }\n        // do nothing\n    }\n  }\n}\n\nvar textFormatters = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  anchor: formatAnchor,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n});\n\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */\nconst DEFAULT_OPTIONS = {\n  baseElements: {\n    selectors: [ 'body' ],\n    orderBy: 'selectors', // 'selectors' | 'occurrence'\n    returnDomByDefault: true\n  },\n  decodeEntities: true,\n  encodeCharacters: {},\n  formatters: {},\n  limits: {\n    ellipsis: '...',\n    maxBaseElements: undefined,\n    maxChildNodes: undefined,\n    maxDepth: undefined,\n    maxInputLength: (1 << 24) // 16_777_216\n  },\n  longWordSplit: {\n    forceWrapOnLimit: false,\n    wrapCharacters: []\n  },\n  preserveNewlines: false,\n  selectors: [\n    { selector: '*', format: 'inline' },\n    {\n      selector: 'a',\n      format: 'anchor',\n      options: {\n        baseUrl: null,\n        hideLinkHrefIfSameAsText: false,\n        ignoreHref: false,\n        linkBrackets: ['[', ']'],\n        noAnchorUrl: true\n      }\n    },\n    { selector: 'article', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'aside', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'blockquote',\n      format: 'blockquote',\n      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }\n    },\n    { selector: 'br', format: 'lineBreak' },\n    { selector: 'div', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'footer', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'form', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },\n    { selector: 'header', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'hr',\n      format: 'horizontalLine',\n      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }\n    },\n    {\n      selector: 'img',\n      format: 'image',\n      options: { baseUrl: null, linkBrackets: ['[', ']'] }\n    },\n    { selector: 'main', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    { selector: 'nav', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'ol',\n      format: 'orderedList',\n      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }\n    },\n    { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },\n    { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },\n    { selector: 'section', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },\n    {\n      selector: 'table',\n      format: 'table',\n      options: {\n        colSpacing: 3,\n        leadingLineBreaks: 2,\n        maxColumnWidth: 60,\n        rowSpacing: 0,\n        trailingLineBreaks: 2,\n        uppercaseHeaderCells: true\n      }\n    },\n    {\n      selector: 'ul',\n      format: 'unorderedList',\n      options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }\n    },\n    { selector: 'wbr', format: 'wbr' },\n  ],\n  tables: [], // deprecated\n  whitespaceCharacters: ' \\t\\r\\n\\f\\u200b',\n  wordwrap: 80\n};\n\nconst concatMerge = (acc, src, options) => [...acc, ...src];\nconst overwriteMerge = (acc, src, options) => [...src];\nconst selectorsMerge = (acc, src, options) => (\n  (acc.some(s => typeof s === 'object'))\n    ? concatMerge(acc, src) // selectors\n    : overwriteMerge(acc, src) // baseElements.selectors\n);\n\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */\nfunction compile (options = {}) {\n  options = merge(\n    DEFAULT_OPTIONS,\n    options,\n    {\n      arrayMerge: overwriteMerge,\n      customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)\n    }\n  );\n  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));\n\n  handleDeprecatedOptions(options);\n\n  return compile$1(options);\n}\n\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */\nfunction convert (html, options = {}, metadata = undefined) {\n  return compile(options)(html, metadata);\n}\n\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */\nfunction handleDeprecatedOptions (options) {\n  if (options.tags) {\n    const tagDefinitions = Object.entries(options.tags).map(\n      ([selector, definition]) => ({ ...definition, selector: selector || '*' })\n    );\n    options.selectors.push(...tagDefinitions);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));\n  }\n\n  function set (obj, path, value) {\n    const valueKey = path.pop();\n    for (const key of path) {\n      let nested = obj[key];\n      if (!nested) {\n        nested = {};\n        obj[key] = nested;\n      }\n      obj = nested;\n    }\n    obj[valueKey] = value;\n  }\n\n  if (options['baseElement']) {\n    const baseElement = options['baseElement'];\n    set(\n      options,\n      ['baseElements', 'selectors'],\n      (Array.isArray(baseElement) ? baseElement : [baseElement])\n    );\n  }\n  if (options['returnDomByDefault'] !== undefined) {\n    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);\n  }\n\n  for (const definition of options.selectors) {\n    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {\n      set(definition, ['options', 'linkBrackets'], false);\n    }\n  }\n}\n\nexport { compile, convert, convert as htmlToText };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}