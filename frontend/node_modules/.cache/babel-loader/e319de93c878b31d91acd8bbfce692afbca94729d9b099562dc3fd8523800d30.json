{"ast":null,"code":"const e = /\\n/g;\nfunction n(n) {\n  const o = [...n.matchAll(e)].map(e => e.index || 0);\n  o.unshift(-1);\n  const s = t(o, 0, o.length);\n  return e => r(s, e);\n}\nfunction t(e, n, r) {\n  if (r - n == 1) return {\n    offset: e[n],\n    index: n + 1\n  };\n  const o = Math.ceil((n + r) / 2),\n    s = t(e, n, o),\n    l = t(e, o, r);\n  return {\n    offset: s.offset,\n    low: s,\n    high: l\n  };\n}\nfunction r(e, n) {\n  return function (e) {\n    return Object.prototype.hasOwnProperty.call(e, \"index\");\n  }(e) ? {\n    line: e.index,\n    column: n - e.offset\n  } : r(e.high.offset < n ? e.high : e.low, n);\n}\nfunction o(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const o = \"string\" != typeof t ? t : r,\n    l = \"string\" == typeof t ? t : \"\",\n    c = e.map(s),\n    f = !!o.lineNumbers;\n  return function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const r = f ? n(e) : () => ({\n      line: 0,\n      column: 0\n    });\n    let o = t;\n    const s = [];\n    e: for (; o < e.length;) {\n      let n = !1;\n      for (const t of c) {\n        t.regex.lastIndex = o;\n        const c = t.regex.exec(e);\n        if (c && c[0].length > 0) {\n          if (!t.discard) {\n            const e = r(o),\n              n = \"string\" == typeof t.replace ? c[0].replace(new RegExp(t.regex.source, t.regex.flags), t.replace) : c[0];\n            s.push({\n              state: l,\n              name: t.name,\n              text: n,\n              offset: o,\n              len: c[0].length,\n              line: e.line,\n              column: e.column\n            });\n          }\n          if (o = t.regex.lastIndex, n = !0, t.push) {\n            const n = t.push(e, o);\n            s.push(...n.tokens), o = n.offset;\n          }\n          if (t.pop) break e;\n          break;\n        }\n      }\n      if (!n) break;\n    }\n    return {\n      tokens: s,\n      offset: o,\n      complete: e.length <= o\n    };\n  };\n}\nfunction s(e, n) {\n  return {\n    ...e,\n    regex: l(e, n)\n  };\n}\nfunction l(e, n) {\n  if (0 === e.name.length) throw new Error(`Rule #${n} has empty name, which is not allowed.`);\n  if (function (e) {\n    return Object.prototype.hasOwnProperty.call(e, \"regex\");\n  }(e)) return function (e) {\n    if (e.global) throw new Error(`Regular expression /${e.source}/${e.flags} contains the global flag, which is not allowed.`);\n    return e.sticky ? e : new RegExp(e.source, e.flags + \"y\");\n  }(e.regex);\n  if (function (e) {\n    return Object.prototype.hasOwnProperty.call(e, \"str\");\n  }(e)) {\n    if (0 === e.str.length) throw new Error(`Rule #${n} (\"${e.name}\") has empty \"str\" property, which is not allowed.`);\n    return new RegExp(c(e.str), \"y\");\n  }\n  return new RegExp(c(e.name), \"y\");\n}\nfunction c(e) {\n  return e.replace(/[-[\\]{}()*+!<=:?./\\\\^$|#\\s,]/g, \"\\\\$&\");\n}\nexport { o as createLexer };","map":{"version":3,"names":["e","n","o","matchAll","map","index","unshift","s","t","length","r","offset","Math","ceil","l","low","high","Object","prototype","hasOwnProperty","call","line","column","arguments","undefined","c","f","lineNumbers","regex","lastIndex","exec","discard","replace","RegExp","source","flags","push","state","name","text","len","tokens","pop","complete","Error","global","sticky","str","createLexer"],"sources":["F:/scandiweb_store/frontend/node_modules/leac/lib/leac.mjs"],"sourcesContent":["const e=/\\n/g;function n(n){const o=[...n.matchAll(e)].map((e=>e.index||0));o.unshift(-1);const s=t(o,0,o.length);return e=>r(s,e)}function t(e,n,r){if(r-n==1)return{offset:e[n],index:n+1};const o=Math.ceil((n+r)/2),s=t(e,n,o),l=t(e,o,r);return{offset:s.offset,low:s,high:l}}function r(e,n){return function(e){return Object.prototype.hasOwnProperty.call(e,\"index\")}(e)?{line:e.index,column:n-e.offset}:r(e.high.offset<n?e.high:e.low,n)}function o(e,t=\"\",r={}){const o=\"string\"!=typeof t?t:r,l=\"string\"==typeof t?t:\"\",c=e.map(s),f=!!o.lineNumbers;return function(e,t=0){const r=f?n(e):()=>({line:0,column:0});let o=t;const s=[];e:for(;o<e.length;){let n=!1;for(const t of c){t.regex.lastIndex=o;const c=t.regex.exec(e);if(c&&c[0].length>0){if(!t.discard){const e=r(o),n=\"string\"==typeof t.replace?c[0].replace(new RegExp(t.regex.source,t.regex.flags),t.replace):c[0];s.push({state:l,name:t.name,text:n,offset:o,len:c[0].length,line:e.line,column:e.column})}if(o=t.regex.lastIndex,n=!0,t.push){const n=t.push(e,o);s.push(...n.tokens),o=n.offset}if(t.pop)break e;break}}if(!n)break}return{tokens:s,offset:o,complete:e.length<=o}}}function s(e,n){return{...e,regex:l(e,n)}}function l(e,n){if(0===e.name.length)throw new Error(`Rule #${n} has empty name, which is not allowed.`);if(function(e){return Object.prototype.hasOwnProperty.call(e,\"regex\")}(e))return function(e){if(e.global)throw new Error(`Regular expression /${e.source}/${e.flags} contains the global flag, which is not allowed.`);return e.sticky?e:new RegExp(e.source,e.flags+\"y\")}(e.regex);if(function(e){return Object.prototype.hasOwnProperty.call(e,\"str\")}(e)){if(0===e.str.length)throw new Error(`Rule #${n} (\"${e.name}\") has empty \"str\" property, which is not allowed.`);return new RegExp(c(e.str),\"y\")}return new RegExp(c(e.name),\"y\")}function c(e){return e.replace(/[-[\\]{}()*+!<=:?./\\\\^$|#\\s,]/g,\"\\\\$&\")}export{o as createLexer};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}