{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { getSuspenseCache, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"../internal/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nexport function useBackgroundQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return wrapHook(\"useBackgroundQuery\", _useBackgroundQuery, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\nfunction _useBackgroundQuery(query, options) {\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n    variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n    queryKey = _a === void 0 ? [] : _a;\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  var didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current || (didFetchResult.current = fetchPolicy !== \"standby\");\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n  var _b = React.useState(wrapQueryRef(queryRef)),\n    wrappedQueryRef = _b[0],\n    setWrappedQueryRef = _b[1];\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    var promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n  // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n  React.useEffect(function () {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    var id = setTimeout(function () {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n    return function () {\n      return clearTimeout(id);\n    };\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n    return promise;\n  }, [queryRef]);\n  React.useEffect(function () {\n    return queryRef.softRetain();\n  }, [queryRef]);\n  return [didFetchResult.current ? wrappedQueryRef : void 0, {\n    fetchMore: fetchMore,\n    refetch: refetch,\n    subscribeToMore: queryRef.observable.subscribeToMore\n  }];\n}","map":{"version":3,"names":["__spreadArray","React","useApolloClient","getSuspenseCache","unwrapQueryRef","updateWrappedQueryRef","wrapQueryRef","wrapHook","useWatchQueryOptions","canonicalStringify","useBackgroundQuery","query","options","Object","create","_useBackgroundQuery","client","undefined","suspenseCache","watchQueryOptions","fetchPolicy","variables","_a","queryKey","didFetchResult","useRef","current","cacheKey","concat","queryRef","getQueryRef","watchQuery","_b","useState","wrappedQueryRef","setWrappedQueryRef","didChangeOptions","promise","applyOptions","useEffect","id","setTimeout","disposed","add","clearTimeout","fetchMore","useCallback","refetch","softRetain","subscribeToMore","observable"],"sources":["C:/laragon/www/php_projects/scandiweb_store/frontend/node_modules/@apollo/client/react/hooks/useBackgroundQuery.js"],"sourcesContent":["import { __spreadArray } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { getSuspenseCache, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef, } from \"../internal/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nexport function useBackgroundQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return wrapHook(\"useBackgroundQuery\", _useBackgroundQuery, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\nfunction _useBackgroundQuery(query, options) {\n    var client = useApolloClient(options.client);\n    var suspenseCache = getSuspenseCache(client);\n    var watchQueryOptions = useWatchQueryOptions({ client: client, query: query, options: options });\n    var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;\n    var _a = options.queryKey, queryKey = _a === void 0 ? [] : _a;\n    // This ref tracks the first time query execution is enabled to determine\n    // whether to return a query ref or `undefined`. When initialized\n    // in a skipped state (either via `skip: true` or `skipToken`) we return\n    // `undefined` for the `queryRef` until the query has been enabled. Once\n    // enabled, a query ref is always returned regardless of whether the query is\n    // skipped again later.\n    var didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n    didFetchResult.current || (didFetchResult.current = fetchPolicy !== \"standby\");\n    var cacheKey = __spreadArray([\n        query,\n        canonicalStringify(variables)\n    ], [].concat(queryKey), true);\n    var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n        return client.watchQuery(watchQueryOptions);\n    });\n    var _b = React.useState(wrapQueryRef(queryRef)), wrappedQueryRef = _b[0], setWrappedQueryRef = _b[1];\n    if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n        setWrappedQueryRef(wrapQueryRef(queryRef));\n    }\n    if (queryRef.didChangeOptions(watchQueryOptions)) {\n        var promise = queryRef.applyOptions(watchQueryOptions);\n        updateWrappedQueryRef(wrappedQueryRef, promise);\n    }\n    // This prevents issues where rerendering useBackgroundQuery after the\n    // queryRef has been disposed would cause the hook to return a new queryRef\n    // instance since disposal also removes it from the suspense cache. We add\n    // the queryRef back in the suspense cache so that the next render will reuse\n    // this queryRef rather than initializing a new instance.\n    React.useEffect(function () {\n        // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n        // tick before checking it and adding back to the suspense cache.\n        var id = setTimeout(function () {\n            if (queryRef.disposed) {\n                suspenseCache.add(cacheKey, queryRef);\n            }\n        });\n        return function () { return clearTimeout(id); };\n        // Omitting the deps is intentional. This avoids stale closures and the\n        // conditional ensures we aren't running the logic on each render.\n    });\n    var fetchMore = React.useCallback(function (options) {\n        var promise = queryRef.fetchMore(options);\n        setWrappedQueryRef(wrapQueryRef(queryRef));\n        return promise;\n    }, [queryRef]);\n    var refetch = React.useCallback(function (variables) {\n        var promise = queryRef.refetch(variables);\n        setWrappedQueryRef(wrapQueryRef(queryRef));\n        return promise;\n    }, [queryRef]);\n    React.useEffect(function () { return queryRef.softRetain(); }, [queryRef]);\n    return [\n        didFetchResult.current ? wrappedQueryRef : void 0,\n        {\n            fetchMore: fetchMore,\n            refetch: refetch,\n            subscribeToMore: queryRef.observable.subscribeToMore,\n        },\n    ];\n}\n//# sourceMappingURL=useBackgroundQuery.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}