{"ast":null,"code":"import { createLexer } from 'leac';\nimport * as p from 'peberminta';\nvar ast = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nconst ws = `(?:[ \\\\t\\\\r\\\\n\\\\f]*)`;\nconst nl = `(?:\\\\n|\\\\r\\\\n|\\\\r|\\\\f)`;\nconst nonascii = `[^\\\\x00-\\\\x7F]`;\nconst unicode = `(?:\\\\\\\\[0-9a-f]{1,6}(?:\\\\r\\\\n|[ \\\\n\\\\r\\\\t\\\\f])?)`;\nconst escape = `(?:\\\\\\\\[^\\\\n\\\\r\\\\f0-9a-f])`;\nconst nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;\nconst nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;\nconst name = `(?:${nmchar}+)`;\nconst ident = `(?:[-]?${nmstart}${nmchar}*)`;\nconst string1 = `'([^\\\\n\\\\r\\\\f\\\\\\\\']|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;\nconst string2 = `\"([^\\\\n\\\\r\\\\f\\\\\\\\\"]|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*\"`;\nconst lexSelector = createLexer([{\n  name: 'ws',\n  regex: new RegExp(ws)\n}, {\n  name: 'hash',\n  regex: new RegExp(`#${name}`, 'i')\n}, {\n  name: 'ident',\n  regex: new RegExp(ident, 'i')\n}, {\n  name: 'str1',\n  regex: new RegExp(string1, 'i')\n}, {\n  name: 'str2',\n  regex: new RegExp(string2, 'i')\n}, {\n  name: '*'\n}, {\n  name: '.'\n}, {\n  name: ','\n}, {\n  name: '['\n}, {\n  name: ']'\n}, {\n  name: '='\n}, {\n  name: '>'\n}, {\n  name: '|'\n}, {\n  name: '+'\n}, {\n  name: '~'\n}, {\n  name: '^'\n}, {\n  name: '$'\n}]);\nconst lexEscapedString = createLexer([{\n  name: 'unicode',\n  regex: new RegExp(unicode, 'i')\n}, {\n  name: 'escape',\n  regex: new RegExp(escape, 'i')\n}, {\n  name: 'any',\n  regex: new RegExp('[\\\\s\\\\S]', 'i')\n}]);\nfunction sumSpec(_ref, _ref2) {\n  let [a0, a1, a2] = _ref;\n  let [b0, b1, b2] = _ref2;\n  return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n  return ss.reduce(sumSpec, [0, 0, 0]);\n}\nconst unicodeEscapedSequence_ = p.token(t => t.name === 'unicode' ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);\nconst escapedSequence_ = p.token(t => t.name === 'escape' ? t.text.slice(1) : undefined);\nconst anyChar_ = p.token(t => t.name === 'any' ? t.text : undefined);\nconst escapedString_ = p.map(p.many(p.or(unicodeEscapedSequence_, escapedSequence_, anyChar_)), cs => cs.join(''));\nfunction unescape(escapedString) {\n  const lexerResult = lexEscapedString(escapedString);\n  const result = escapedString_({\n    tokens: lexerResult.tokens,\n    options: undefined\n  }, 0);\n  return result.value;\n}\nfunction literal(name) {\n  return p.token(t => t.name === name ? true : undefined);\n}\nconst whitespace_ = p.token(t => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = p.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n  return p.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p.token(t => t.name === 'ident' ? unescape(t.text) : undefined);\nconst hashId_ = p.token(t => t.name === 'hash' ? unescape(t.text.slice(1)) : undefined);\nconst string_ = p.token(t => t.name.startsWith('str') ? unescape(t.text.slice(1, -1)) : undefined);\nconst namespace_ = p.left(p.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = p.eitherOr(p.ab(namespace_, identifier_, (ns, name) => ({\n  name: name,\n  namespace: ns\n})), p.map(identifier_, name => ({\n  name: name,\n  namespace: null\n})));\nconst uniSelector_ = p.eitherOr(p.ab(namespace_, literal('*'), ns => ({\n  type: 'universal',\n  namespace: ns,\n  specificity: [0, 0, 0]\n})), p.map(literal('*'), () => ({\n  type: 'universal',\n  namespace: null,\n  specificity: [0, 0, 0]\n})));\nconst tagSelector_ = p.map(qualifiedName_, _ref3 => {\n  let {\n    name,\n    namespace\n  } = _ref3;\n  return {\n    type: 'tag',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 0, 1]\n  };\n});\nconst classSelector_ = p.ab(literal('.'), identifier_, (fullstop, name) => ({\n  type: 'class',\n  name: name,\n  specificity: [0, 1, 0]\n}));\nconst idSelector_ = p.map(hashId_, name => ({\n  type: 'id',\n  name: name,\n  specificity: [1, 0, 0]\n}));\nconst attrModifier_ = p.token(t => {\n  if (t.name === 'ident') {\n    if (t.text === 'i' || t.text === 'I') {\n      return 'i';\n    }\n    if (t.text === 's' || t.text === 'S') {\n      return 's';\n    }\n  }\n  return undefined;\n});\nconst attrValue_ = p.eitherOr(p.ab(string_, p.option(p.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({\n  value: v,\n  modifier: mod\n})), p.ab(identifier_, p.option(p.right(whitespace_, attrModifier_), null), (v, mod) => ({\n  value: v,\n  modifier: mod\n})));\nconst attrMatcher_ = p.choice(p.map(literal('='), () => '='), p.ab(literal('~'), literal('='), () => '~='), p.ab(literal('|'), literal('='), () => '|='), p.ab(literal('^'), literal('='), () => '^='), p.ab(literal('$'), literal('='), () => '$='), p.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = p.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, _ref4) => {\n  let {\n    name,\n    namespace\n  } = _ref4;\n  return {\n    type: 'attrPresence',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 1, 0]\n  };\n});\nconst attrValueSelector_ = p.middle(literal('['), p.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), (_ref5, matcher, _ref6) => {\n  let {\n    name,\n    namespace\n  } = _ref5;\n  let {\n    value,\n    modifier\n  } = _ref6;\n  return {\n    type: 'attrValue',\n    name: name,\n    namespace: namespace,\n    matcher: matcher,\n    value: value,\n    modifier: modifier,\n    specificity: [0, 1, 0]\n  };\n}), literal(']'));\nconst attrSelector_ = p.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p.map(p.eitherOr(p.flatten(typeSelector_, p.many(subclassSelector_)), p.many1(subclassSelector_)), ss => {\n  return {\n    type: 'compound',\n    list: ss,\n    specificity: sumAllSpec(ss.map(s => s.specificity))\n  };\n});\nconst combinator_ = p.choice(p.map(literal('>'), () => '>'), p.map(literal('+'), () => '+'), p.map(literal('~'), () => '~'), p.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = p.eitherOr(optionallySpaced(combinator_), p.map(whitespace_, () => ' '));\nconst complexSelector_ = p.leftAssoc2(compoundSelector_, p.map(combinatorSeparator_, c => (left, right) => ({\n  type: 'compound',\n  list: [...right.list, {\n    type: 'combinator',\n    combinator: c,\n    left: left,\n    specificity: left.specificity\n  }],\n  specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = p.leftAssoc2(p.map(complexSelector_, s => ({\n  type: 'list',\n  list: [s]\n})), p.map(optionallySpaced(literal(',')), () => (acc, next) => ({\n  type: 'list',\n  list: [...acc.list, next]\n})), complexSelector_);\nfunction parse_(parser, str) {\n  if (!(typeof str === 'string' || str instanceof String)) {\n    throw new Error('Expected a selector string. Actual input is not a string!');\n  }\n  const lexerResult = lexSelector(str);\n  if (!lexerResult.complete) {\n    throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` + prettyPrintPosition(str, lexerResult.offset));\n  }\n  const result = optionallySpaced(parser)({\n    tokens: lexerResult.tokens,\n    options: undefined\n  }, 0);\n  if (!result.matched) {\n    throw new Error(`No match for \"${str}\" input!`);\n  }\n  if (result.position < lexerResult.tokens.length) {\n    const token = lexerResult.tokens[result.position];\n    throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` + prettyPrintPosition(str, token.offset, token.len));\n  }\n  return result.value;\n}\nfunction prettyPrintPosition(str, offset) {\n  let len = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n  return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n  return parse_(complexSelector_, str);\n}\nfunction serialize(selector) {\n  if (!selector.type) {\n    throw new Error('This is not an AST node.');\n  }\n  switch (selector.type) {\n    case 'universal':\n      return _serNs(selector.namespace) + '*';\n    case 'tag':\n      return _serNs(selector.namespace) + _serIdent(selector.name);\n    case 'class':\n      return '.' + _serIdent(selector.name);\n    case 'id':\n      return '#' + _serIdent(selector.name);\n    case 'attrPresence':\n      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;\n    case 'attrValue':\n      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}\"${_serStr(selector.value)}\"${selector.modifier ? selector.modifier : ''}]`;\n    case 'combinator':\n      return serialize(selector.left) + selector.combinator;\n    case 'compound':\n      return selector.list.reduce((acc, node) => {\n        if (node.type === 'combinator') {\n          return serialize(node) + acc;\n        } else {\n          return acc + serialize(node);\n        }\n      }, '');\n    case 'list':\n      return selector.list.map(serialize).join(',');\n  }\n}\nfunction _serNs(ns) {\n  return ns || ns === '' ? _serIdent(ns) + '|' : '';\n}\nfunction _codePoint(char) {\n  return `\\\\${char.codePointAt(0).toString(16)} `;\n}\nfunction _serIdent(str) {\n  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\\x00-\\x7F])|(\\x00)|([\\x01-\\x1f]|\\x7f)|([\\s\\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) : d2 ? '-' + _codePoint(d2.slice(1)) : hy ? '\\\\-' : safe ? safe : nl ? '\\ufffd' : ctrl ? _codePoint(ctrl) : '\\\\' + other);\n}\nfunction _serStr(str) {\n  return str.replace(/(\")|(\\\\)|(\\x00)|([\\x01-\\x1f]|\\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\\\\"' : bs ? '\\\\\\\\' : nl ? '\\ufffd' : _codePoint(ctrl));\n}\nfunction normalize(selector) {\n  if (!selector.type) {\n    throw new Error('This is not an AST node.');\n  }\n  switch (selector.type) {\n    case 'compound':\n      {\n        selector.list.forEach(normalize);\n        selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n        break;\n      }\n    case 'combinator':\n      {\n        normalize(selector.left);\n        break;\n      }\n    case 'list':\n      {\n        selector.list.forEach(normalize);\n        selector.list.sort((a, b) => serialize(a) < serialize(b) ? -1 : 1);\n        break;\n      }\n  }\n  return selector;\n}\nfunction _getSelectorPriority(selector) {\n  switch (selector.type) {\n    case 'universal':\n      return [1];\n    case 'tag':\n      return [1];\n    case 'id':\n      return [2];\n    case 'class':\n      return [3, selector.name];\n    case 'attrPresence':\n      return [4, serialize(selector)];\n    case 'attrValue':\n      return [5, serialize(selector)];\n    case 'combinator':\n      return [15, serialize(selector)];\n  }\n}\nfunction compareSelectors(a, b) {\n  return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n  return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    throw new Error('Arguments must be arrays.');\n  }\n  const shorter = a.length < b.length ? a.length : b.length;\n  for (let i = 0; i < shorter; i++) {\n    if (a[i] === b[i]) {\n      continue;\n    }\n    return a[i] < b[i] ? -1 : 1;\n  }\n  return a.length - b.length;\n}\nexport { ast as Ast, compareSelectors, compareSpecificity, normalize, parse, parse1, serialize };","map":{"version":3,"names":["createLexer","p","ast","Object","freeze","__proto__","ws","nl","nonascii","unicode","escape","nmstart","nmchar","name","ident","string1","string2","lexSelector","regex","RegExp","lexEscapedString","sumSpec","_ref","_ref2","a0","a1","a2","b0","b1","b2","sumAllSpec","ss","reduce","unicodeEscapedSequence_","token","t","String","fromCodePoint","parseInt","text","slice","undefined","escapedSequence_","anyChar_","escapedString_","map","many","or","cs","join","unescape","escapedString","lexerResult","result","tokens","options","value","literal","whitespace_","optionalWhitespace_","option","optionallySpaced","parser","middle","identifier_","hashId_","string_","startsWith","namespace_","left","qualifiedName_","eitherOr","ab","ns","namespace","uniSelector_","type","specificity","tagSelector_","_ref3","classSelector_","fullstop","idSelector_","attrModifier_","attrValue_","right","v","mod","modifier","attrMatcher_","choice","attrPresenceSelector_","abc","lbr","_ref4","attrValueSelector_","_ref5","matcher","_ref6","attrSelector_","typeSelector_","subclassSelector_","compoundSelector_","flatten","many1","list","s","combinator_","combinatorSeparator_","complexSelector_","leftAssoc2","c","combinator","listSelector_","acc","next","parse_","str","Error","complete","offset","prettyPrintPosition","matched","position","length","len","arguments","replace","m","r","padEnd","repeat","parse","parse1","serialize","selector","_serNs","_serIdent","_serStr","node","_codePoint","char","codePointAt","toString","d1","d2","hy","safe","ctrl","other","dq","bs","normalize","forEach","sort","a","b","_compareArrays","_getSelectorPriority","compareSelectors","compareSpecificity","Array","isArray","shorter","i","Ast"],"sources":["F:/scandiweb_store/frontend/node_modules/parseley/lib/parseley.mjs"],"sourcesContent":["import { createLexer } from 'leac';\nimport * as p from 'peberminta';\n\nvar ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst ws = `(?:[ \\\\t\\\\r\\\\n\\\\f]*)`;\nconst nl = `(?:\\\\n|\\\\r\\\\n|\\\\r|\\\\f)`;\nconst nonascii = `[^\\\\x00-\\\\x7F]`;\nconst unicode = `(?:\\\\\\\\[0-9a-f]{1,6}(?:\\\\r\\\\n|[ \\\\n\\\\r\\\\t\\\\f])?)`;\nconst escape = `(?:\\\\\\\\[^\\\\n\\\\r\\\\f0-9a-f])`;\nconst nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape})`;\nconst nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape})`;\nconst name = `(?:${nmchar}+)`;\nconst ident = `(?:[-]?${nmstart}${nmchar}*)`;\nconst string1 = `'([^\\\\n\\\\r\\\\f\\\\\\\\']|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*'`;\nconst string2 = `\"([^\\\\n\\\\r\\\\f\\\\\\\\\"]|\\\\\\\\${nl}|${nonascii}|${unicode}|${escape})*\"`;\nconst lexSelector = createLexer([\n    { name: 'ws', regex: new RegExp(ws) },\n    { name: 'hash', regex: new RegExp(`#${name}`, 'i') },\n    { name: 'ident', regex: new RegExp(ident, 'i') },\n    { name: 'str1', regex: new RegExp(string1, 'i') },\n    { name: 'str2', regex: new RegExp(string2, 'i') },\n    { name: '*' },\n    { name: '.' },\n    { name: ',' },\n    { name: '[' },\n    { name: ']' },\n    { name: '=' },\n    { name: '>' },\n    { name: '|' },\n    { name: '+' },\n    { name: '~' },\n    { name: '^' },\n    { name: '$' },\n]);\nconst lexEscapedString = createLexer([\n    { name: 'unicode', regex: new RegExp(unicode, 'i') },\n    { name: 'escape', regex: new RegExp(escape, 'i') },\n    { name: 'any', regex: new RegExp('[\\\\s\\\\S]', 'i') }\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [0, 0, 0]);\n}\nconst unicodeEscapedSequence_ = p.token((t) => t.name === 'unicode' ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);\nconst escapedSequence_ = p.token((t) => t.name === 'escape' ? t.text.slice(1) : undefined);\nconst anyChar_ = p.token((t) => t.name === 'any' ? t.text : undefined);\nconst escapedString_ = p.map(p.many(p.or(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(''));\nfunction unescape(escapedString) {\n    const lexerResult = lexEscapedString(escapedString);\n    const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);\n    return result.value;\n}\nfunction literal(name) {\n    return p.token((t) => t.name === name ? true : undefined);\n}\nconst whitespace_ = p.token((t) => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = p.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return p.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p.token((t) => t.name === 'ident' ? unescape(t.text) : undefined);\nconst hashId_ = p.token((t) => t.name === 'hash' ? unescape(t.text.slice(1)) : undefined);\nconst string_ = p.token((t) => t.name.startsWith('str') ? unescape(t.text.slice(1, -1)) : undefined);\nconst namespace_ = p.left(p.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = p.eitherOr(p.ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), p.map(identifier_, (name) => ({ name: name, namespace: null })));\nconst uniSelector_ = p.eitherOr(p.ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), p.map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));\nconst tagSelector_ = p.map(qualifiedName_, ({ name, namespace }) => ({\n    type: 'tag',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 0, 1]\n}));\nconst classSelector_ = p.ab(literal('.'), identifier_, (fullstop, name) => ({\n    type: 'class',\n    name: name,\n    specificity: [0, 1, 0]\n}));\nconst idSelector_ = p.map(hashId_, (name) => ({\n    type: 'id',\n    name: name,\n    specificity: [1, 0, 0]\n}));\nconst attrModifier_ = p.token((t) => {\n    if (t.name === 'ident') {\n        if (t.text === 'i' || t.text === 'I') {\n            return 'i';\n        }\n        if (t.text === 's' || t.text === 'S') {\n            return 's';\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = p.eitherOr(p.ab(string_, p.option(p.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), p.ab(identifier_, p.option(p.right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));\nconst attrMatcher_ = p.choice(p.map(literal('='), () => '='), p.ab(literal('~'), literal('='), () => '~='), p.ab(literal('|'), literal('='), () => '|='), p.ab(literal('^'), literal('='), () => '^='), p.ab(literal('$'), literal('='), () => '$='), p.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = p.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({\n    type: 'attrPresence',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 1, 0]\n}));\nconst attrValueSelector_ = p.middle(literal('['), p.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({\n    type: 'attrValue',\n    name: name,\n    namespace: namespace,\n    matcher: matcher,\n    value: value,\n    modifier: modifier,\n    specificity: [0, 1, 0]\n})), literal(']'));\nconst attrSelector_ = p.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p.map(p.eitherOr(p.flatten(typeSelector_, p.many(subclassSelector_)), p.many1(subclassSelector_)), (ss) => {\n    return {\n        type: 'compound',\n        list: ss,\n        specificity: sumAllSpec(ss.map(s => s.specificity))\n    };\n});\nconst combinator_ = p.choice(p.map(literal('>'), () => '>'), p.map(literal('+'), () => '+'), p.map(literal('~'), () => '~'), p.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = p.eitherOr(optionallySpaced(combinator_), p.map(whitespace_, () => ' '));\nconst complexSelector_ = p.leftAssoc2(compoundSelector_, p.map(combinatorSeparator_, (c) => (left, right) => ({\n    type: 'compound',\n    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],\n    specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = p.leftAssoc2(p.map(complexSelector_, (s) => ({ type: 'list', list: [s] })), p.map(optionallySpaced(literal(',')), () => (acc, next) => ({ type: 'list', list: [...acc.list, next] })), complexSelector_);\nfunction parse_(parser, str) {\n    if (!(typeof str === 'string' || str instanceof String)) {\n        throw new Error('Expected a selector string. Actual input is not a string!');\n    }\n    const lexerResult = lexSelector(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` +\n            prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` +\n            prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\n\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'universal':\n            return _serNs(selector.namespace) + '*';\n        case 'tag':\n            return _serNs(selector.namespace) + _serIdent(selector.name);\n        case 'class':\n            return '.' + _serIdent(selector.name);\n        case 'id':\n            return '#' + _serIdent(selector.name);\n        case 'attrPresence':\n            return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;\n        case 'attrValue':\n            return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}\"${_serStr(selector.value)}\"${(selector.modifier ? selector.modifier : '')}]`;\n        case 'combinator':\n            return serialize(selector.left) + selector.combinator;\n        case 'compound':\n            return selector.list.reduce((acc, node) => {\n                if (node.type === 'combinator') {\n                    return serialize(node) + acc;\n                }\n                else {\n                    return acc + serialize(node);\n                }\n            }, '');\n        case 'list':\n            return selector.list.map(serialize).join(',');\n    }\n}\nfunction _serNs(ns) {\n    return (ns || ns === '')\n        ? _serIdent(ns) + '|'\n        : '';\n}\nfunction _codePoint(char) {\n    return `\\\\${char.codePointAt(0).toString(16)} `;\n}\nfunction _serIdent(str) {\n    return str.replace(\n    /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\\x00-\\x7F])|(\\x00)|([\\x01-\\x1f]|\\x7f)|([\\s\\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) :\n        d2 ? '-' + _codePoint(d2.slice(1)) :\n            hy ? '\\\\-' :\n                safe ? safe :\n                    nl ? '\\ufffd' :\n                        ctrl ? _codePoint(ctrl) :\n                            '\\\\' + other);\n}\nfunction _serStr(str) {\n    return str.replace(\n    /(\")|(\\\\)|(\\x00)|([\\x01-\\x1f]|\\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\\\\"' :\n        bs ? '\\\\\\\\' :\n            nl ? '\\ufffd' :\n                _codePoint(ctrl));\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'compound': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n            break;\n        }\n        case 'combinator': {\n            normalize(selector.left);\n            break;\n        }\n        case 'list': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);\n            break;\n        }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch (selector.type) {\n        case 'universal':\n            return [1];\n        case 'tag':\n            return [1];\n        case 'id':\n            return [2];\n        case 'class':\n            return [3, selector.name];\n        case 'attrPresence':\n            return [4, serialize(selector)];\n        case 'attrValue':\n            return [5, serialize(selector)];\n        case 'combinator':\n            return [15, serialize(selector)];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error('Arguments must be arrays.');\n    }\n    const shorter = (a.length < b.length) ? a.length : b.length;\n    for (let i = 0; i < shorter; i++) {\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return (a[i] < b[i]) ? -1 : 1;\n    }\n    return a.length - b.length;\n}\n\nexport { ast as Ast, compareSelectors, compareSpecificity, normalize, parse, parse1, serialize };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}